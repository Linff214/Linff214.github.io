<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>高性能并发服务器 | 小林小林爱编程</title><meta name="author" content="Linff214"><meta name="copyright" content="Linff214"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="[ubuntu安装vmtools教程以及显示unable to execute](ubuntu安装wmwaretools教程以及显示 unable to execute “usr&#x2F;bin&#x2F;vmware-uninstall-tools.pl”解决办法 - 傻逼离我远点 - 博客园 (cnblogs.com)) 使用 &lt;font&gt; 的标签的修改文字前景色红色绿色蓝色 使">
<meta property="og:type" content="article">
<meta property="og:title" content="高性能并发服务器">
<meta property="og:url" content="https://linff214.github.io/2024/04/21/%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8/index.html">
<meta property="og:site_name" content="小林小林爱编程">
<meta property="og:description" content="[ubuntu安装vmtools教程以及显示unable to execute](ubuntu安装wmwaretools教程以及显示 unable to execute “usr&#x2F;bin&#x2F;vmware-uninstall-tools.pl”解决办法 - 傻逼离我远点 - 博客园 (cnblogs.com)) 使用 &lt;font&gt; 的标签的修改文字前景色红色绿色蓝色 使">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://linff214.github.io/img/%E7%8C%AB%E7%8C%AB2.jpg">
<meta property="article:published_time" content="2024-04-21T08:16:28.000Z">
<meta property="article:modified_time" content="2024-05-21T13:40:01.031Z">
<meta property="article:author" content="Linff214">
<meta property="article:tag" content="Linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://linff214.github.io/img/%E7%8C%AB%E7%8C%AB2.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://linff214.github.io/2024/04/21/%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Linff214","link":"链接: ","source":"来源: 小林小林爱编程","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '高性能并发服务器',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-05-21 21:40:01'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/color.css"><link rel="stylesheet" href="/css/essay.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (true) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/%E5%A4%B4%E5%83%8F.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/essay/"><i class="fa-fw fas fa-folder-open"></i><span> 小林的朋友圈</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/%E7%8C%AB%E7%8C%AB2.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="小林小林爱编程"><span class="site-name">小林小林爱编程</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/essay/"><i class="fa-fw fas fa-folder-open"></i><span> 小林的朋友圈</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">高性能并发服务器</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-04-21T08:16:28.000Z" title="发表于 2024-04-21 16:16:28">2024-04-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-05-21T13:40:01.031Z" title="更新于 2024-05-21 21:40:01">2024-05-21</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%B7%A5%E4%BD%9C-%E9%A1%B9%E7%9B%AE/">工作/项目</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="高性能并发服务器"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>[ubuntu安装vmtools教程以及显示unable to execute](<a target="_blank" rel="noopener" href="https://www.cnblogs.com/jnhs/p/14097576.html">ubuntu安装wmwaretools教程以及显示 unable to execute “usr&#x2F;bin&#x2F;vmware-uninstall-tools.pl”解决办法 - 傻逼离我远点 - 博客园 (cnblogs.com)</a>)</p>
<h4 id="使用-lt-font-gt-的标签的修改文字前景色"><a href="#使用-lt-font-gt-的标签的修改文字前景色" class="headerlink" title="使用 &lt;font&gt; 的标签的修改文字前景色"></a>使用 <code>&lt;font&gt;</code> 的标签的修改文字前景色</h4><p><font color="red">红色</font><br><font color="green">绿色</font><br><font color="blue">蓝色</font></p>
<p><font color="rgb(200, 100, 100)">使用 rgb 颜色值</font></p>
<p><font color="#FF00BB">使用十六进制颜色值</font></p>
<h2 id="1-Gcc"><a href="#1-Gcc" class="headerlink" title="1. Gcc"></a>1. Gcc</h2><p><img src="https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421163720798.png" alt="image-20240421163720798"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421163802549.png" alt="image-20240421163802549"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421163903356.png" alt="image-20240421163903356"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421164151578.png" alt="image-20240421164151578"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421164214532.png" alt="image-20240421164214532"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421164359576.png" alt="image-20240421164359576"></p>
<h2 id="2-静态库制作和使用"><a href="#2-静态库制作和使用" class="headerlink" title="2. 静态库制作和使用"></a>2. 静态库制作和使用</h2><p><img src="https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421164514336.png" alt="image-20240421164514336"></p>
<hr>
<p><img src="https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421164609215.png" alt="image-20240421164609215"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421164629772.png" alt="image-20240421164629772"></p>
<ul>
<li><p><code>cp calc library ../lession06 -r</code>  将当前文件夹<code>lession05</code>下的<code>calc</code>和<code>library</code>文件复制到上一级目录下的<code>lession05</code>中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">nowcoder@nowcoder:~/Linux/lession06$ tree</span><br><span class="line">.</span><br><span class="line">├── calc</span><br><span class="line">│   ├── add.c</span><br><span class="line">│   ├── add.o</span><br><span class="line">│   ├── div.c</span><br><span class="line">│   ├── div.o</span><br><span class="line">│   ├── head.h</span><br><span class="line">│   ├── libcalc.a</span><br><span class="line">│   ├── main.c</span><br><span class="line">│   ├── mult.c</span><br><span class="line">│   ├── mult.o</span><br><span class="line">│   ├── sub.c</span><br><span class="line">│   └── sub.o</span><br><span class="line">└── library</span><br><span class="line">    ├── app</span><br><span class="line">    ├── include</span><br><span class="line">    │   └── head.h</span><br><span class="line">    ├── lib</span><br><span class="line">    │   └── libcalc.a</span><br><span class="line">    ├── main.c</span><br><span class="line">    └── src</span><br><span class="line">        ├── add.c</span><br><span class="line">        ├── div.c</span><br><span class="line">        ├── mult.c</span><br><span class="line">        └── sub.c</span><br><span class="line"></span><br><span class="line"><span class="number">5</span> directories, <span class="number">19</span> files</span><br><span class="line">nowcoder@nowcoder:~/Linux/lession06$ cd calc</span><br><span class="line">nowcoder@nowcoder:~/Linux/lession06/calc$ rm *.o libcalc.a 删除calc下的.o文件和库文件</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3-制作动态库"><a href="#3-制作动态库" class="headerlink" title="3. 制作动态库"></a>3. 制作动态库</h2><ul>
<li><p>1.制作动态库<code>gcc -c -fpic add.c div.c sub.c mult.c</code></p>
<p>​      <code>gcc -shared *.o -o libcalc.so</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421165213230.png" alt="image-20240421165213230"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421165240002.png" alt="image-20240421165240002"></p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421165305089.png" alt="image-20240421165305089"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421165527751.png" alt="image-20240421165527751"></p>
<ul>
<li><ol start="2">
<li><p>ldd +可执行文件（查看动态库地址加载情况）</p>
<p>env查看环境变量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">nowcoder@nowcoder:~/Linux/lession06/library$ ll</span><br><span class="line">总用量 <span class="number">36</span></span><br><span class="line">drwxrwxr-x <span class="number">5</span> nowcoder nowcoder <span class="number">4096</span> <span class="number">4</span>月  <span class="number">13</span> <span class="number">10</span>:<span class="number">52</span> ./</span><br><span class="line">drwxrwxr-x <span class="number">4</span> nowcoder nowcoder <span class="number">4096</span> <span class="number">4</span>月  <span class="number">13</span> <span class="number">10</span>:<span class="number">16</span> ../</span><br><span class="line">drwxrwxr-x <span class="number">2</span> nowcoder nowcoder <span class="number">4096</span> <span class="number">4</span>月  <span class="number">13</span> <span class="number">10</span>:<span class="number">16</span> include/</span><br><span class="line">drwxrwxr-x <span class="number">2</span> nowcoder nowcoder <span class="number">4096</span> <span class="number">4</span>月  <span class="number">13</span> <span class="number">10</span>:<span class="number">43</span> lib/</span><br><span class="line">-rwxrwxr-x <span class="number">1</span> nowcoder nowcoder <span class="number">8424</span> <span class="number">4</span>月  <span class="number">13</span> <span class="number">10</span>:<span class="number">52</span> main*</span><br><span class="line">-rw-rw-r-- <span class="number">1</span> nowcoder nowcoder  <span class="number">306</span> <span class="number">4</span>月  <span class="number">13</span> <span class="number">10</span>:<span class="number">16</span> main.c</span><br><span class="line">drwxrwxr-x <span class="number">2</span> nowcoder nowcoder <span class="number">4096</span> <span class="number">4</span>月  <span class="number">13</span> <span class="number">10</span>:<span class="number">16</span> src/</span><br><span class="line">nowcoder@nowcoder:~/Linux/lession06/library$ ldd main</span><br><span class="line">	linux-vdso.so<span class="number">.1</span> (<span class="number">0x00007fffa132c000</span>)</span><br><span class="line">	libcalc.so =&gt; not found  <span class="comment">//&lt;-看这里</span></span><br><span class="line">	libc.so<span class="number">.6</span> =&gt; /lib/x86_64-linux-gnu/libc.so<span class="number">.6</span> (<span class="number">0x00007f986a129000</span>)</span><br><span class="line">	/lib64/ld-linux-x86<span class="number">-64.</span>so<span class="number">.2</span> (<span class="number">0x00007f986a71c000</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h3 id="3-1export添加环境变量（临时）"><a href="#3-1export添加环境变量（临时）" class="headerlink" title="3.1export添加环境变量（临时）"></a>3.1export添加环境变量（临时）</h3><p><img src="https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421165835484.png" alt="image-20240421165835484"></p>
<p><code>pwd</code>查看当前文件夹所在路径</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">nowcoder@nowcoder:~/Linux/lession06/library$ cd lib</span><br><span class="line">nowcoder@nowcoder:~/Linux/lession06/library/lib$ pwd</span><br><span class="line">/home/nowcoder/Linux/lession06/library/lib      <span class="comment">//这个就是路径</span></span><br></pre></td></tr></table></figure>

<p>echo命令用于输出变量的值</p>
<p>​	<code>echo $LD_LIBRARY_PATH:/home/nowcoder/Linux/lession06/library/lib</code></p>
<h3 id="3-2添加换变量（长期）"><a href="#3-2添加换变量（长期）" class="headerlink" title="3.2添加换变量（长期）"></a>3.2添加换变量（长期）</h3><p><img src="https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421170419092.png" alt="image-20240421170419092"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421170443780.png" alt="image-20240421170443780"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421170507456.png" alt="image-20240421170507456"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421170525234.png" alt="image-20240421170525234"></p>
<h3 id="3-3动静态库的优缺点"><a href="#3-3动静态库的优缺点" class="headerlink" title="3.3动静态库的优缺点"></a>3.3动静态库的优缺点</h3><p><img src="C:\Users\lin'xin'xin\AppData\Roaming\Typora\typora-user-images\image-20240421170617522.png" alt="image-20240421170617522"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421170641672.png" alt="image-20240421170641672"></p>
<hr>
<h2 id="4-Makefile"><a href="#4-Makefile" class="headerlink" title="4. Makefile"></a>4. Makefile</h2><h3 id="4-1-什么是Makefile"><a href="#4-1-什么是Makefile" class="headerlink" title="4.1 什么是Makefile"></a><strong>4.1 什么是Makefile</strong></h3><ul>
<li>一个工程中的源文件不计其数，其按类型、功能、模块分别放在若干个目录中Makefile 文件定义了一系列的规则来指定哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为Makefile 文件就像一个 shel1 脚本一样，也可以执行操作系统的命令。Makefile 带来的好处就是“自动化编译”，一旦写好，只需要一个 make 命令，整个工程完全自动编译，极大的提高了软件开发的效率。make 是一个命令工具，是一个解释 Makefile 文件中指令的命令工具，一般来说，大多数的 IDE 都有这个命令比如Delphi的make,VisualC++的nmake,Linux下GNU 的 make。</li>
</ul>
<p><strong>4.2 Makefile 文件命名和规则文件命名</strong></p>
<ul>
<li>文件命名<br>makefile 或者Makefile</li>
<li>Makefile 规则<ul>
<li>一个Makefile 文件中可以有一个或者多个规则<ul>
<li><font color="red">目标… :  依赖…</font><br><font color = "red">命令(shell 命令)</font><br>目标:最终要生成的文件(伪目标除外)<br>依赖:生成目标所需要的文件或是目标<br>命令:通过执行命令对依赖操作生成目标(命令前必须Tab 缩进)口</li>
<li>Makefile 中的其它规则一般都是为第一条规则服务的。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="4-3-工作原理"><a href="#4-3-工作原理" class="headerlink" title="4.3 工作原理"></a><strong>4.3 工作原理</strong></h3><ul>
<li><p>命令在执行之前，需要先检查规则中的依赖是否存在</p>
<ul>
<li>如果存在，执行命令</li>
<li>如果不存在，向不检查其它的规则，检查有没有一个规则是用来生成这个依赖的如果找到了，则执行该规则中的命令</li>
</ul>
</li>
<li><p>检测更新，在执行规则中的命令时，会比较目标和依赖文件的时间</p>
<ul>
<li><p>如果依赖的时间比目标的时间晚，需要重新生成目标</p>
</li>
<li><p>如果依赖的时间比目标的时间早，目标不需要更新，对应规则中的命令不需要被执行</p>
</li>
</ul>
</li>
</ul>
<h3 id="4-4-自定义变量"><a href="#4-4-自定义变量" class="headerlink" title="4.4 自定义变量"></a>4.4 自定义变量</h3><p><img src="https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421171831820.png" alt="image-20240421171831820"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421172046159.png" alt="image-20240421172046159"></p>
<h3 id="4-5-模式匹配"><a href="#4-5-模式匹配" class="headerlink" title="4.5 模式匹配"></a>4.5 模式匹配</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">add.o:add.c</span><br><span class="line">	gcc -c add.c</span><br><span class="line">div.o:div.c</span><br><span class="line">	gcc -c div.c</span><br><span class="line">sub.o:sub.c</span><br><span class="line">	gcc -c sub.c</span><br><span class="line">mult.o:mult.c</span><br><span class="line">	gcc -c mult.c</span><br><span class="line">main.o:main.c</span><br><span class="line">	gcc -c main.c</span><br><span class="line">%.o:%.c</span><br><span class="line">	-%:通配符，匹配一个字符串</span><br><span class="line">	-两个%匹配的是同一个字符串名</span><br><span class="line">%.o:%.c</span><br><span class="line">	gcc -c $&lt; -o $@</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421172502971.png" alt="image-20240421172502971"></p>
<h3 id="4-6-函数"><a href="#4-6-函数" class="headerlink" title="4.6 函数"></a>4.6 函数</h3><ul>
<li><p>$(wildcard PATTERN…)</p>
<ul>
<li><p>功能: 获取指定目录下指定类型的文件列表</p>
</li>
<li><p>参数: PATTERN 指的是某个或多个目录下的对应的某种类型的文件，如果有多个目录，一般使用空格间隔</p>
</li>
<li><p>返回:得到的若干个文件的文件列表，文件名之间使用空格间隔</p>
</li>
<li><p>示例:<br><code>$(wildcard .c ./sub/.c)</code></p>
<ul>
<li><p>返回值格式: <code>a.c b.c c.c d.c e.c f.c</code></p>
<ul>
<li>&#96;&#96;&#96;C<br>#定义变量<br>#获取指定目录下的.o文件 sub.o add.o mult.o div.o main.o<br>src&#x3D;$(wildcard.&#x2F;*.c)<br>target&#x3D;app<br>$(target):$(src)<br>    $(CC) $(src) -o $(target)<br>%.o:%.c<br>    $(CC) -c $&lt; -o $@<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">* $(patsubst&lt;pattern&gt;，&lt;replacement&gt;，&lt;text&gt;</span><br><span class="line"></span><br><span class="line">  *  功能: 查找&lt;text&gt;中的单词(单词以“空格”、“Tab&quot;或“回车”“换行”分隔)是否符合模式&lt;pattern&gt;，如果匹配的话，则以&lt;replacement&gt;替换。</span><br><span class="line"></span><br><span class="line">  * &lt;pattern&gt;可以包括通配符`%`，表示任意长度的字串。如果&lt;replacement&gt;中也包含`%`，那么，&lt;replacement&gt;中的这个`%`将是&lt;pattern&gt;中的那个`%`所代表的字串。(可以用`\`来转义，以`\%`来表示真实含义的`%`字符)</span><br><span class="line"></span><br><span class="line">  * 返回: 函数返回被替换过后的字符串</span><br><span class="line"></span><br><span class="line">  * 示例:</span><br><span class="line"></span><br><span class="line">    * `$(patsubst %.c，%.o，x.c bar.c)`</span><br><span class="line"></span><br><span class="line">    * 返回值格式:`x.o bar.o`</span><br><span class="line"></span><br><span class="line">    * ```</span><br><span class="line">      #获取指定目录下的.o文件 sub.o add.o mult.o div.o main.o</span><br><span class="line">      src=$(wildcard./*.c)</span><br><span class="line">      objs=$(patsubst %.c,%.o,$(src))</span><br><span class="line">      target=app</span><br><span class="line">      $(target):$(src)</span><br><span class="line">      		$(CC) $(src) -o $(target)</span><br><span class="line">      %.o:%.c</span><br><span class="line">      		$(CC) -c $&lt; -o $@</span><br><span class="line">      		</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421175808645.png" alt="image-20240421175808645"></p>
</li>
<li><p>touch 文件名——创建文件</p>
</li>
</ul>
<p>  .PHONY： 文件名O——生成伪目标文件O</p>
<ul>
<li><img src="https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421175837436.png" alt="image-20240421175837436"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="5-GBD调试"><a href="#5-GBD调试" class="headerlink" title="5. GBD调试"></a>5. GBD调试</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/dshf_1/article/details/99973236">linux命令 ll信息详解_ll命令-CSDN博客</a></p>
<h3 id="5-1-什么是-GDB"><a href="#5-1-什么是-GDB" class="headerlink" title="5.1 什么是 GDB"></a>5.1 什么是 GDB</h3><ul>
<li>GDB 是由 GNU 软件系统社区提供的调试工具，同GCC配套组成了一套完整的开发环境，GDB是Linux和许多类Unix系统中的标准开发环境。</li>
<li>一般来说，GDB 主要帮助你完成下面四个方面的功能:<ul>
<li>1.启动程序，可以按照自定义的要求随心所欲的运行程序<br>2.可让被调试的程序在所指定的调置的断点处停住(断点可以是条件表达式)<br>3.当程序被停住时，可以检查此时程序中所发生的事<br>可以改变程序，将一个 BUG 产生的影响修正从而测试其他BUG4.</li>
</ul>
</li>
</ul>
<h3 id="5-2-准备工作"><a href="#5-2-准备工作" class="headerlink" title="5.2 准备工作"></a>5.2 准备工作</h3><ul>
<li><p>通常，在为调试而编译时，我们会()关掉编译器的优化选项(-o)，并打开调试选项(-g)。另外，<code>-wa11</code>在尽量不影响程序行为的情况下选项打开所有<code>warning</code>，也可以发现许多问题，避免一些不必要的BUG。</p>
</li>
<li><p><code>gcc -g-Wall program.c o program</code></p>
</li>
<li><p><code>-g</code>选项的作用是在可执行文件中加入源代码的信息，比如可执行文件中第几条机器指令对应源代码的第几行，但并不是把整个源文件嵌入到可执行文件中，所以在调试时必须保证 gdb 能找到源文件。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">nowcoder@nowcoder:~/Linux/lession08$ gcc test.c -o test -g</span><br><span class="line">nowcoder@nowcoder:~/Linux/lession08$ gcc test.c -o test1</span><br><span class="line">nowcoder@nowcoder:~/Linux/lession08$ ll -h</span><br><span class="line">总用量 <span class="number">52</span>K</span><br><span class="line">-rwxrwxr-x <span class="number">1</span> nowcoder nowcoder  <span class="number">11</span>K <span class="number">4</span>月  <span class="number">14</span> <span class="number">20</span>:<span class="number">26</span> test*</span><br><span class="line">-rwxrwxr-x <span class="number">1</span> nowcoder nowcoder <span class="number">8.3</span>K <span class="number">4</span>月  <span class="number">14</span> <span class="number">20</span>:<span class="number">26</span> test1*</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-3-GDB命令-启动、推出、查看代码"><a href="#5-3-GDB命令-启动、推出、查看代码" class="headerlink" title="5.3 GDB命令-启动、推出、查看代码"></a>5.3 GDB命令-启动、推出、查看代码</h3><ul>
<li><p><strong>启动和退出</strong><br>gdb 可执行程序</p>
<p>quit</p>
</li>
<li><p><strong>给程序设置参数</strong>&#x2F;<strong>获取设置参数</strong><br>set args 1020<br>show args</p>
</li>
<li><p><strong>GDB</strong> <strong>使用帮助</strong><br>help</p>
</li>
<li><p><strong>查看当前文件代码</strong></p>
<p>list&#x2F;1 (从默认位置显示)<br>list&#x2F;1行号 (从指定的行显示)<br>list&#x2F;1 函数名(从指定的函数显示)</p>
</li>
<li><p><strong>查看非当前文件代码</strong></p>
<p>list&#x2F;l 文件名:行号</p>
<p>list&#x2F;l 文件名:函数名</p>
</li>
<li><p><strong>设置显示的行数</strong><br>show list&#x2F;listsize<br>set list&#x2F;listsize 行数</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(gdb) <span class="built_in">list</span></span><br><span class="line"><span class="number">1</span>	<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="number">2</span>	<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span>	<span class="type">int</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a)</span>;</span><br><span class="line"><span class="number">5</span>	</span><br><span class="line"><span class="number">6</span>	<span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> &#123;</span><br><span class="line"><span class="number">7</span>	    <span class="type">int</span> a, b;</span><br><span class="line"><span class="number">8</span>	    <span class="built_in">printf</span>(<span class="string">&quot;argc = %d\n&quot;</span>, argc);</span><br><span class="line"><span class="number">9</span>	</span><br><span class="line"><span class="number">10</span>	    <span class="keyword">if</span>(argc &lt; <span class="number">3</span>) &#123;</span><br><span class="line">(gdb) l <span class="number">20</span></span><br><span class="line"><span class="number">15</span>	        b = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"><span class="number">16</span>	    &#125;</span><br><span class="line"><span class="number">17</span>	    <span class="built_in">printf</span>(<span class="string">&quot;a = %d, b = %d\n&quot;</span>, a, b);</span><br><span class="line"><span class="number">18</span>	    <span class="built_in">printf</span>(<span class="string">&quot;a + b = %d\n&quot;</span>, a + b);</span><br><span class="line"><span class="number">19</span>	</span><br><span class="line"><span class="number">20</span>	    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; a; ++i) &#123;</span><br><span class="line"><span class="number">21</span>	        <span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i);</span><br><span class="line"><span class="number">22</span>	        <span class="comment">// 函数调用</span></span><br><span class="line"><span class="number">23</span>	        <span class="type">int</span> res = test(i);</span><br><span class="line"><span class="number">24</span>	        <span class="built_in">printf</span>(<span class="string">&quot;res value: %d\n&quot;</span>, res);</span><br><span class="line">(gdb) <span class="built_in">list</span> main</span><br><span class="line"><span class="number">1</span>	<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="number">2</span>	<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="number">3</span>	</span><br><span class="line"><span class="number">4</span>	<span class="type">int</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a)</span>;</span><br><span class="line"><span class="number">5</span>	</span><br><span class="line"><span class="number">6</span>	<span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> &#123;</span><br><span class="line"><span class="number">7</span>	    <span class="type">int</span> a, b;</span><br><span class="line"><span class="number">8</span>	    <span class="built_in">printf</span>(<span class="string">&quot;argc = %d\n&quot;</span>, argc);</span><br><span class="line"><span class="number">9</span>	</span><br><span class="line"><span class="number">10</span>	    <span class="keyword">if</span>(argc &lt; <span class="number">3</span>) &#123;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="5-4-GBD命令-断点操作"><a href="#5-4-GBD命令-断点操作" class="headerlink" title="5.4 GBD命令-断点操作"></a>5.4 GBD命令-断点操作</h3><p><img src="https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421181214061.png" alt="image-20240421181214061"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(gdb) <span class="keyword">break</span> <span class="number">9</span></span><br><span class="line">Breakpoint <span class="number">1</span> at <span class="number">0xb2c</span>: file main.cpp, line <span class="number">9.</span></span><br><span class="line">(gdb) b main</span><br><span class="line">Breakpoint <span class="number">2</span> at <span class="number">0xafa</span>: file main.cpp, line <span class="number">6.</span></span><br><span class="line">b bubble.cpp:<span class="number">11</span></span><br><span class="line">Breakpoint <span class="number">3</span> at <span class="number">0xa18</span>: file bubble.cpp, line <span class="number">11.</span></span><br><span class="line"> b bubble.cpp:bubbleSort</span><br><span class="line">Breakpoint <span class="number">4</span> at <span class="number">0x9b5</span>: file bubble.cpp, line <span class="number">8.</span></span><br><span class="line">(gdb) i b</span><br><span class="line">Num     Type           Disp Enb Address            What</span><br><span class="line"><span class="number">1</span>       breakpoint     keep y   <span class="number">0x0000000000000b2c</span> in <span class="title function_">main</span><span class="params">()</span> at main.cpp:9</span><br><span class="line">2       breakpoint     keep y   0x0000000000000afa in <span class="title function_">main</span><span class="params">()</span> at main.cpp:6</span><br><span class="line">3       breakpoint     keep y   0x0000000000000a18 in <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>*, <span class="type">int</span>)</span> </span><br><span class="line">                                                   at bubble.cpp:11</span><br><span class="line">4       breakpoint     keep y   0x00000000000009b5 in <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>*, <span class="type">int</span>)</span> </span><br><span class="line">                                                   at bubble.cpp:8</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="5-5-GBD命令-调试命令"><a href="#5-5-GBD命令-调试命令" class="headerlink" title="5.5 GBD命令-调试命令"></a>5.5 GBD命令-调试命令</h3><p><img src="https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421181324553.png" alt="image-20240421181324553"></p>
<hr>
<h2 id="6-文件I-x2F-O（针对内存而言）"><a href="#6-文件I-x2F-O（针对内存而言）" class="headerlink" title="6. 文件I&#x2F;O（针对内存而言）"></a>6. 文件I&#x2F;O（针对内存而言）</h2><h3 id="6-1-标准C库IO函数"><a href="#6-1-标准C库IO函数" class="headerlink" title="6.1 标准C库IO函数"></a>6.1 标准C库IO函数</h3><p>1、标准C库I&#x2F;O函数与Linux系统I&#x2F;O函数的区别</p>
<p>（1）标准C库I&#x2F;O函数在读写的时候，中间有一个缓冲区，而Linux系统I&#x2F;O函数没有缓冲区；如果中间有缓冲区的话在进行读写操作的时候会先存到缓冲区，再刷新到磁盘，它比直接逐条读写到磁盘效率要高。</p>
<p>（2）根据应用场景选择合适的I&#x2F;O函数，如：再进行网络通信时就应该使用Linux系统I&#x2F;O函数，因为通信更要求实时性；而在对磁盘进行读写时则选择标准C库I&#x2F;O函数。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_47156401/article/details/125658799">标准C库I&#x2F;O函数与Linux系统I&#x2F;O函数对比（通俗易懂）_标准c库io函数和linux系统io函数对比-CSDN博客</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421181551255.png" alt="image-20240421181551255"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421181628087.png" alt="image-20240421181628087"></p>
<h3 id="6-2-标准C库IO和Linux系统和IO关系"><a href="#6-2-标准C库IO和Linux系统和IO关系" class="headerlink" title="6.2 标准C库IO和Linux系统和IO关系"></a>6.2 标准C库IO和Linux系统和IO关系</h3><p>[68-文件I&#x2F;O：标准C库IO函数和Linux系统IO函数对比-CSDN博客](<a target="_blank" rel="noopener" href="https://blog.csdn.net/Edward_LF/article/details/124398047#:~:text=%E6%A0%87%E5%87%86c%E5%BA%93%E5%87%BD%E6%95%B0%E5%92%8Clinux%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0%E5%8C%BA%E5%88%AB%EF%BC%9A">https://blog.csdn.net/Edward_LF/article/details/124398047#:~:text=标准c库函数和linux系统函数区别：</a> 标准c库可以跨平台；（调用了不同平台的系统API）,在linux平台中，调用c库函数，底层是调用的是linux中的系统函数 linux系统I%2FO函数是没有缓冲区的，调用一次就会访问一次)</p>
<p><img src="https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421181845943.png" alt="image-20240421181845943"></p>
<h3 id="6-3-虚拟地址空间"><a href="#6-3-虚拟地址空间" class="headerlink" title="6.3 虚拟地址空间"></a>6.3 虚拟地址空间</h3><ul>
<li>一个进程对应一个虚拟地址空间，由CPU中的MMU内存管理映射到真实的物理地址，程序（.c、.exe）并不占用内存空间，只占用磁盘空间。进程占用内存。文件描述符在内核区。</li>
<li><img src="https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421182111634.png" alt="image-20240421182111634"></li>
</ul>
<h3 id="6-4-文件描述符"><a href="#6-4-文件描述符" class="headerlink" title="6.4 文件描述符"></a>6.4 文件描述符</h3><p><img src="https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421182153263.png" alt="image-20240421182153263"></p>
<h3 id="6-5-open打开文件"><a href="#6-5-open打开文件" class="headerlink" title="6.5 open打开文件"></a>6.5 open打开文件</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*open 打开文件</span></span><br><span class="line"><span class="comment"> #include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> #include &lt;sys/stat.h&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> #include &lt;fcntl.h&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> // 打开一个已经存在的文件</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">int open(const char *pathname, int flags);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   - pathname：要打开的文件路径</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   - flags：对文件的操作权限设置还有其他的设置</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      O_RDONLY,  O_WRONLY, O_RDWR  这三个设置是互斥的</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   返回值：返回一个新的文件描述符，如果调用失败，返回-1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  errno：属于Linux系统函数库，库里面的一个全局变量，记录的是最近的错误号</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> #include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  void perror(const char *s);作用：打印errno对应的错误描述</span></span><br><span class="line"><span class="comment">    参数：用户描述，比如hello,最终输出的内容是  hello:xxx(实际的错误描述)</span></span><br><span class="line"><span class="comment">    // 创建一个新的文件&lt;/font&gt;</span></span><br><span class="line"><span class="comment">	int open(c/usr/bin/gcconst char *pathname, int flags, mode_t mode);&lt;/font&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 打开一个文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;a.txt&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读写操作</span></span><br><span class="line">    <span class="comment">// 关闭</span></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="6-6-open创建新文件"><a href="#6-6-open创建新文件" class="headerlink" title="6.6 open创建新文件"></a>6.6 open创建新文件</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*open创建新文件</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  \#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  \#include &lt;sys/stat.h&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  \#include &lt;fcntl.h&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  int open(const char *pathname, int flags, mode_t mode);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    参数：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      \- pathname：要创建的文件的路径</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      \- flags：对文件的操作权限和其他的设置</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        \- 必选项：O_RDONLY, O_WRONLY, O_RDWR  这三个之间是互斥的</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        \- 可选项：O_CREAT 文件不存在，创建新文件</span></span><br><span class="line"><span class="comment">      \- mode：八进制的数，表示创建出的新的文件的操作权限，比如：0775</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      最终的权限是：mode &amp; ~umask</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      0777  -&gt;  111111111</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &amp;  0775  -&gt;  111111101</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    \----------------------------</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            111111101</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    按位与：0和任何数都为0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   umask的作用就是抹去某些权限。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   flags参数是一个int类型的数据，占4个字节，32位。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   flags 32个位，每一位就是一个标志位。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个新的文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;create.txt&quot;</span>, O_RDWR | O_CREAT, <span class="number">0777</span>);| O_CREAT创建文件的新标志</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 关闭</span></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-5-Linux系统i-x2F-o函数"><a href="#6-5-Linux系统i-x2F-o函数" class="headerlink" title="6.5 Linux系统i&#x2F;o函数"></a>6.5 Linux系统i&#x2F;o函数</h3><p><img src="https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421201504240.png" alt="image-20240421201504240"></p>
<ul>
<li><p><strong>read函数</strong>读取数据是指从文件中读取数据到内存中</p>
</li>
<li><p><strong>write函数</strong>写数据是指把内存中数据写到文件中</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">    ssize_t read(int fd, void *buf, size_t count);</span></span><br><span class="line"><span class="comment">        参数：</span></span><br><span class="line"><span class="comment">            - fd：文件描述符，open得到的，通过这个文件描述符操作某个文件</span></span><br><span class="line"><span class="comment">            - buf：需要读取数据存放的地方，数组的地址（传出参数）</span></span><br><span class="line"><span class="comment">            - count：指定的数组的大小</span></span><br><span class="line"><span class="comment">        返回值：</span></span><br><span class="line"><span class="comment">            - 成功：</span></span><br><span class="line"><span class="comment">                &gt;0: 返回实际的读取到的字节数</span></span><br><span class="line"><span class="comment">                =0：文件已经读取完了</span></span><br><span class="line"><span class="comment">            - 失败：-1 ，并且设置errno</span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">    ssize_t write(int fd, const void *buf, size_t count);</span></span><br><span class="line"><span class="comment">        参数：</span></span><br><span class="line"><span class="comment">            - fd：文件描述符，open得到的，通过这个文件描述符操作某个文件</span></span><br><span class="line"><span class="comment">            - buf：要往磁盘写入的数据，数组</span></span><br><span class="line"><span class="comment">            - count：要写的数据的实际的大小</span></span><br><span class="line"><span class="comment">        返回值：</span></span><br><span class="line"><span class="comment">            成功：实际写入的字节数</span></span><br><span class="line"><span class="comment">            失败：返回-1，并设置errno</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.通过open打开english.txt文件</span></span><br><span class="line">    <span class="type">int</span> srcfd = open(<span class="string">&quot;english.txt&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(srcfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.创建一个新的文件（拷贝文件）</span></span><br><span class="line">    <span class="type">int</span> destfd = open(<span class="string">&quot;cpy.txt&quot;</span>, O_WRONLY | O_CREAT, <span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span>(destfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.频繁的读写操作</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((len = read(srcfd, buf, <span class="keyword">sizeof</span>(buf))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        write(destfd, buf, len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.关闭文件</span></span><br><span class="line">    close(destfd);</span><br><span class="line">    close(srcfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="6-6lseek函数"><a href="#6-6lseek函数" class="headerlink" title="6.6lseek函数"></a>6.6lseek函数</h3><p>——移动文件指针到文件头、获取当前文件指针的位置、获取文件长度、拓展文件的长度</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment">    标准C库的函数</span></span><br><span class="line"><span class="comment">    #include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">    int fseek(FILE *stream, long offset, int whence);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Linux系统函数</span></span><br><span class="line"><span class="comment">    #include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">    off_t lseek(int fd, off_t offset, int whence);</span></span><br><span class="line"><span class="comment">        参数：</span></span><br><span class="line"><span class="comment">            - fd：文件描述符，通过open得到的，通过这个fd操作某个文件</span></span><br><span class="line"><span class="comment">            - offset：偏移量</span></span><br><span class="line"><span class="comment">            - whence:</span></span><br><span class="line"><span class="comment">                SEEK_SET</span></span><br><span class="line"><span class="comment">                    设置文件指针的偏移量</span></span><br><span class="line"><span class="comment">                SEEK_CUR</span></span><br><span class="line"><span class="comment">                    设置偏移量：当前位置 + 第二个参数offset的值</span></span><br><span class="line"><span class="comment">                SEEK_END</span></span><br><span class="line"><span class="comment">                    设置偏移量：文件大小 + 第二个参数offset的值</span></span><br><span class="line"><span class="comment">        返回值：返回文件指针的位置</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    作用：</span></span><br><span class="line"><span class="comment">        1.移动文件指针到文件头</span></span><br><span class="line"><span class="comment">        lseek(fd, 0, SEEK_SET);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        2.获取当前文件指针的位置</span></span><br><span class="line"><span class="comment">        lseek(fd, 0, SEEK_CUR);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        3.获取文件长度</span></span><br><span class="line"><span class="comment">        lseek(fd, 0, SEEK_END);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        4.拓展文件的长度，当前文件10b, 110b, 增加了100个字节</span></span><br><span class="line"><span class="comment">        lseek(fd, 100, SEEK_END)</span></span><br><span class="line"><span class="comment">        注意：需要写一次数据</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;hello.txt&quot;</span>, O_RDWR);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩展文件的长度</span></span><br><span class="line">    <span class="type">int</span> ret = lseek(fd, <span class="number">100</span>, SEEK_END);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;lseek&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入一个空数据</span></span><br><span class="line">    write(fd, <span class="string">&quot; &quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="6-6-lstat函数和stat函数"><a href="#6-6-lstat函数和stat函数" class="headerlink" title="6.6 lstat函数和stat函数"></a>6.6 lstat函数和stat函数</h3><p>——获取一个文件相关的一些信息</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//stat 结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span>&#123;</span></span><br><span class="line"><span class="type">dev_t</span>		st_dev;		<span class="comment">// 文件的设备编号</span></span><br><span class="line"><span class="type">ino_t</span>		st_ino;		<span class="comment">// 节点</span></span><br><span class="line"><span class="type">mode_t</span>		st_mode;	<span class="comment">//文件的类型和存取的权限</span></span><br><span class="line"><span class="type">nlink_t</span>		st_nlink;	<span class="comment">//连到该文件的硬连接数目</span></span><br><span class="line"><span class="type">uid_t</span>		st_uid;		<span class="comment">//用户ID</span></span><br><span class="line"><span class="type">gid_t</span>		st_gid;		<span class="comment">//组ID</span></span><br><span class="line"><span class="type">dev_t</span>		st_rdev;	<span class="comment">//设备文件的设备编号</span></span><br><span class="line"><span class="type">off_t</span>		st_size;	<span class="comment">//文件字节数(文件大小)</span></span><br><span class="line"><span class="type">blksize_t</span>	st_blksize;	<span class="comment">//块大小</span></span><br><span class="line"><span class="type">blkcnt_t</span>	st_blocks;	<span class="comment">//块数</span></span><br><span class="line"><span class="type">time_t</span>		st_atime;	<span class="comment">//最后一次访问时间</span></span><br><span class="line"><span class="type">time_t</span>		st_mtime;	<span class="comment">//最后一次修改时间</span></span><br><span class="line"><span class="type">time_t</span>		st_ctime;	<span class="comment">//最后一次改变时间(指属性</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">       #include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">       #include &lt;sys/stat.h&gt;</span></span><br><span class="line"><span class="comment">       #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       int stat(const char *pathname, struct stat *statbuf);</span></span><br><span class="line"><span class="comment">       作用：获取一个文件相关的一些信息</span></span><br><span class="line"><span class="comment">       参数：</span></span><br><span class="line"><span class="comment">            -pathname:操作文件的路径</span></span><br><span class="line"><span class="comment">            -statbuf：结构体变量，传出参数，用于保存获取到的文件信息</span></span><br><span class="line"><span class="comment">        返回值:</span></span><br><span class="line"><span class="comment">        成功：返回0；</span></span><br><span class="line"><span class="comment">        失败：返回-1，并设置errno；</span></span><br><span class="line"><span class="comment">       int lstat(const char *pathname, struct stat *statbuf);</span></span><br><span class="line"><span class="comment">       作用：获取软连接文件相关的一些信息</span></span><br><span class="line"><span class="comment">       参数：</span></span><br><span class="line"><span class="comment">            -pathname:操作文件的路径</span></span><br><span class="line"><span class="comment">            -statbuf：结构体变量，传出参数，用于保存获取到的文件信息</span></span><br><span class="line"><span class="comment">        返回值:</span></span><br><span class="line"><span class="comment">        成功：返回0；</span></span><br><span class="line"><span class="comment">        失败：返回-1，并设置errno；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">statbuf</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = stat(<span class="string">&quot;a.txt&quot;</span>, &amp;statbuf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;stat&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;size: %ld\n&quot;</span>, statbuf.st_size);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>判断权限，应该和相应的宏与&amp;操作；判断文件类型，将mode与掩码与&amp;操作，再和宏进行比较<img src="https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240421204638015.png" alt="image-20240421204638015"></li>
</ul>
<h3 id="6-7模拟实现ls-l命令"><a href="#6-7模拟实现ls-l命令" class="headerlink" title="6.7模拟实现ls-l命令"></a>6.7模拟实现ls-l命令</h3><p>——ls-l命令能够获取当前目录下文件的信息</p>
<p>​	ls-l xx.txt查看当前xx文件的信息</p>
<p>2024&#x2F;04&#x2F;21</p>
<h3 id="6-8-文件属性操作函数"><a href="#6-8-文件属性操作函数" class="headerlink" title="6.8 文件属性操作函数"></a>6.8 文件属性操作函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">access</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> mode)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">chmod</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">int</span> mode)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">chown</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">uid_t</span> owner, <span class="type">gid_t</span> group)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">truncate</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">off_t</span> length)</span>;</span><br></pre></td></tr></table></figure>

<ol>
<li>*<em>int access(const char <em>pathname, int mode);</em></em></li>
</ol>
<p>​	——作用：判断某个文件是否具有某个权限，或者判断文件是否存在</p>
<p>​	——参数：</p>
<p>​      - pathname: 判断的文件路径</p>
<p>​      - mode:</p>
<p>​        R_OK: 判断是否有读权限</p>
<p>​        W_OK: 判断是否有写权限</p>
<p>​        X_OK: 判断是否有执行权限</p>
<p>​        F_OK: 判断文件是否存在</p>
<p>​       返回值：成功返回0， 失败返回-1</p>
<ol start="2">
<li>*<em>int chmod(const char <em>filename, int mode_t);</em></em></li>
</ol>
<p>​	—— 作用：修改文件的权限</p>
<p>​         参数：</p>
<p>​        - pathname: 需要修改的文件的路径</p>
<p>​        - mode:需要修改的权限值，八进制的数</p>
<p>​          返回值：成功返回0，失败返回-1</p>
<ol start="3">
<li><p><strong>int</strong> *<em>chown(const char <em>path, uid_t owner, gid_t group);</em></em></p>
<p>—— 作用：修改文件的所有者或所在组</p>
<p><code>vim /etc/passwd</code>——显示所有的用户和id、组id</p>
<p><code>vim /etc/group</code>——查看当前系统所有组和id</p>
<p><code>useradd xx</code>——创建xx用户</p>
<p><code>id xx</code>——查看xxid</p>
</li>
<li><p><strong>int truncate(const char path, off_t length);</strong></p>
<p>作用：缩减或者扩展文件的尺寸至指定的大小</p>
<p>​    参数：</p>
<p>​      - path: 需要修改的文件的路径</p>
<p>​      - length: 需要最终文件变成的大小</p>
<p>​    返回值：</p>
<p>​      成功返回0， 失败返回-1</p>
<p>——<code>touch xx.xx</code> 创建xx.x文件</p>
<p>——<code>vim xx.x</code>进入xx.x文件</p>
</li>
</ol>
<h3 id="6-9-目录操作函数"><a href="#6-9-目录操作函数" class="headerlink" title="6.9 目录操作函数"></a>6.9 目录操作函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mkdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">rmdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">rename</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *oldpath, <span class="type">const</span> <span class="type">char</span> *newpath)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">chdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span>;</span><br><span class="line"><span class="type">char</span> *<span class="title function_">getcwd</span><span class="params">(<span class="type">char</span> *buf, <span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure>

<ol>
<li>*<em>int mkdir(const char <em>pathname, mode_t mode);</em></em></li>
</ol>
<p>​	<code>man 2 xxx</code>——查看Linux系统函数xx</p>
<p>​	—— 作用：创建一个目录</p>
<p>​    	参数：</p>
<p>​     	 pathname: 创建的目录的路径</p>
<p>​      	mode: 权限，八进制的数</p>
<p>​    	返回值：</p>
<p>​      	成功返回0， 失败返回-1</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = mkdir(<span class="string">&quot;aaa&quot;</span>, <span class="number">0777</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;mkdir&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：创建了aaa目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nowcoder@nowcoder:~/Linux/lesson14$ gcc mkdir.c -o mkdir</span><br><span class="line">nowcoder@nowcoder:~/Linux/lesson14$ ./mkdir</span><br><span class="line">nowcoder@nowcoder:~/Linux/lesson14$ ll</span><br><span class="line">总用量 36</span><br><span class="line">drwxrwxr-x 3 nowcoder nowcoder 4096 4月  22 13:31 ./</span><br><span class="line">drwxr-xr-x 9 nowcoder nowcoder 4096 4月  22 11:35 ../</span><br><span class="line">drwxrwxr-x 2 nowcoder nowcoder 4096 4月  22 13:31 aaa/</span><br><span class="line">-rw-rw-r-- 1 nowcoder nowcoder 1369 4月  22 11:35 chdir.c</span><br><span class="line">-rwxrwxr-x 1 nowcoder nowcoder 8344 4月  22 13:31 mkdir*</span><br><span class="line">-rw-rw-r-- 1 nowcoder nowcoder  519 4月  22 11:35 mkdir.c</span><br><span class="line">-rw-rw-r-- 1 nowcoder nowcoder  246 4月  22 11:35 rename.c</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>*<em>int rmdir(const char <em>pathname);</em></em></p>
<p>——作用：删除空目录</p>
</li>
<li><p>**int rename(const char <em>oldpath, const char <em>newpath);</em></em></p>
<p>——作用：重命名</p>
</li>
<li><p>*<em>int chdir(const char <em>path);</em></em></p>
<p>——作用：修改进程的工作目录</p>
<p>比如在&#x2F;home&#x2F;nowcoder 启动了一个可执行程序a.out, 进程的工作目录 &#x2F;home&#x2F;nowcoder</p>
<p>——参数：</p>
<p>​      path : 需要修改的工作目录</p>
</li>
<li><p>**char <em>getcwd(char <em>buf, size_t size);</em></em></p>
</li>
</ol>
<p>​	——作用：获取当前的工作路径</p>
<p>​	参数：</p>
<p>​      	- buf : 存储的路径，指向的是一个数组（传出参数）</p>
<p>​     	 - size: 数组的大小</p>
<p>​        返回值：</p>
<p>​        	 返回的指向的一块内存，这个数据就是第一个参数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前的工作目录</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line">    getcwd(buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;当前的工作目录是：%s\n&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改工作目录</span></span><br><span class="line">    <span class="type">int</span> ret = chdir(<span class="string">&quot;/home/nowcoder/Linux/lesson13&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;chdir&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个新的文件,在当前工作目录下创建</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;chdir.txt&quot;</span>, O_CREAT | O_RDWR, <span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前的工作目录</span></span><br><span class="line">    <span class="type">char</span> buf1[<span class="number">128</span>];</span><br><span class="line">    getcwd(buf1, <span class="keyword">sizeof</span>(buf1));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;当前的工作目录是：%s\n&quot;</span>, buf1);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="6-10-目录遍历函数"><a href="#6-10-目录遍历函数" class="headerlink" title="6.10 目录遍历函数"></a>6.10 目录遍历函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DIR *<span class="title function_">opendir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;			<span class="comment">//打开目录</span></span><br><span class="line"><span class="keyword">struct</span> dirent *<span class="title function_">readdir</span><span class="params">(DIR *dirp)</span>;		<span class="comment">//读取目录</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">closedir</span><span class="params">(DIR *dirp)</span>;				<span class="comment">//关闭目录</span></span><br></pre></td></tr></table></figure>

<p>shell终端输入<code>man 3 xx</code>——查看标准C库函数</p>
<ul>
<li>dirent结构体和d_type</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240422203357809.png" alt="image-20240422203357809"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    // 打开一个目录</span></span><br><span class="line"><span class="comment">    #include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;dirent.h&gt;</span></span><br><span class="line"><span class="comment">    DIR *opendir(const char *name);</span></span><br><span class="line"><span class="comment">        参数：</span></span><br><span class="line"><span class="comment">            - name: 需要打开的目录的名称</span></span><br><span class="line"><span class="comment">        返回值：</span></span><br><span class="line"><span class="comment">            DIR * 类型，理解为目录流</span></span><br><span class="line"><span class="comment">            错误返回NULL</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // 读取目录中的数据,每调用一次reader就在目录流中往后读取一个目录</span></span><br><span class="line"><span class="comment">    #include &lt;dirent.h&gt;</span></span><br><span class="line"><span class="comment">    struct dirent *readdir(DIR *dirp);</span></span><br><span class="line"><span class="comment">        - 参数：dirp是opendir返回的结果</span></span><br><span class="line"><span class="comment">        - 返回值：</span></span><br><span class="line"><span class="comment">            struct dirent，代表读取到的文件的信息</span></span><br><span class="line"><span class="comment">            读取到了末尾或者失败了，返回NULL</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // 关闭目录</span></span><br><span class="line"><span class="comment">    #include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;dirent.h&gt;</span></span><br><span class="line"><span class="comment">    int closedir(DIR *dirp);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getFileNum</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * path)</span>;</span><br><span class="line"><span class="comment">// 读取某个目录下所有的普通文件的个数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> * argv[])</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s path\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> num = getFileNum(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;普通文件的个数为：%d\n&quot;</span>, num);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用于获取目录下所有普通文件的个数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getFileNum</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * path)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.打开目录</span></span><br><span class="line">    DIR * dir = opendir(path);</span><br><span class="line">    <span class="keyword">if</span>(dir == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;opendir&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">ptr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录普通文件的个数</span></span><br><span class="line">    <span class="type">int</span> total = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>((ptr = readdir(dir)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取名称</span></span><br><span class="line">        <span class="type">char</span> * dname = ptr-&gt;d_name;</span><br><span class="line">        <span class="comment">// 忽略掉. 和..</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(dname, <span class="string">&quot;.&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(dname, <span class="string">&quot;..&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断是否是普通文件还是目录</span></span><br><span class="line">        <span class="keyword">if</span>(ptr-&gt;d_type == DT_DIR) &#123;</span><br><span class="line">            <span class="comment">// 目录,需要继续读取这个目录</span></span><br><span class="line">            <span class="type">char</span> newpath[<span class="number">256</span>];</span><br><span class="line">            <span class="built_in">sprintf</span>(newpath, <span class="string">&quot;%s/%s&quot;</span>, path, dname);</span><br><span class="line">            total += getFileNum(newpath);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ptr-&gt;d_type == DT_REG) &#123;</span><br><span class="line">            <span class="comment">// 普通文件</span></span><br><span class="line">            total++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 关闭目录</span></span><br><span class="line">    closedir(dir);</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-11-dup、dup2函数"><a href="#6-11-dup、dup2函数" class="headerlink" title="6.11 dup、dup2函数"></a>6.11 dup、dup2函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">dup</span><span class="params">(<span class="type">int</span> oldfd)</span>;</span><br><span class="line">复制文件描述符</span><br><span class="line"><span class="type">int</span> <span class="title function_">dup2</span><span class="params">(<span class="type">int</span> oldfd,<span class="type">int</span> newfd)</span>;</span><br><span class="line">重定向文件描述符</span><br></pre></td></tr></table></figure>

<ol>
<li><p>#include &lt;unistd.h&gt;</p>
<p>int dup(int oldfd);</p>
</li>
</ol>
<p>​    	作用：复制一个新的文件描述符,指向同一个文件</p>
<p>​    	fd&#x3D;3, int fd1 &#x3D; dup(fd),</p>
<p>​    	fd指向的是a.txt, fd1也是指向a.txt</p>
<p>​    	从空闲的文件描述符表中找一个最小的，作为新的拷贝的文件描述符</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;a.txt&quot;</span>, O_RDWR | O_CREAT, <span class="number">0664</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd1 = dup(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fd1 == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;dup&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd : %d , fd1 : %d\n&quot;</span>, fd, fd1);</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> * str = <span class="string">&quot;hello,world&quot;</span>;</span><br><span class="line">    <span class="type">int</span> ret = write(fd1, str, <span class="built_in">strlen</span>(str));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>#include &lt;unistd.h&gt;</p>
<p>  int dup2(int oldfd, int newfd);</p>
<p>​    作用：重定向文件描述符</p>
<p>​    oldfd 指向 a.txt, newfd 指向 b.txt</p>
<p>​    调用函数成功后：newfd 和 b.txt 做close, newfd 指向了 a.txt</p>
<p>​    oldfd 必须是一个有效的文件描述符</p>
<p>​    oldfd和newfd值相同，相当于什么都没有做</p>
<p>​    返回值是：return the  new  file  descriptor</p>
<p>*&#x2F;</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;1.txt&quot;</span>, O_RDWR | O_CREAT, <span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd1 = open(<span class="string">&quot;2.txt&quot;</span>, O_RDWR | O_CREAT, <span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd1 == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd : %d, fd1 : %d\n&quot;</span>, fd, fd1);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd2 = dup2(fd, fd1);<span class="comment">//fd2==fd1</span></span><br><span class="line">    <span class="keyword">if</span>(fd2 == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;dup2&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过fd1去写数据，实际操作的是1.txt，而不是2.txt</span></span><br><span class="line">    <span class="type">char</span> * str = <span class="string">&quot;hello, dup2&quot;</span>;</span><br><span class="line">    <span class="type">int</span> len = write(fd1, str, <span class="built_in">strlen</span>(str));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd : %d, fd1 : %d, fd2 : %d\n&quot;</span>, fd, fd1, fd2);</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    close(fd1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="6-12-fcntl函数"><a href="#6-12-fcntl函数" class="headerlink" title="6.12  fcntl函数"></a>6.12  fcntl函数</h3><ol>
<li>**int fcntl ( int fd, int cmd, …&#x2F;<em>arg <em>&#x2F; );</em></em><br>复制文件描述符<br>设置&#x2F;获取文件的状态标志</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;fcntl.h&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    int fcntl(int fd, int cmd, ...);</span></span><br><span class="line"><span class="comment">    参数：</span></span><br><span class="line"><span class="comment">        fd : 表示需要操作的文件描述符</span></span><br><span class="line"><span class="comment">        cmd: 表示对文件描述符进行如何操作</span></span><br><span class="line"><span class="comment">            - F_DUPFD : 复制文件描述符,复制的是第一个参数fd，得到一个新的文件描述符（返回值）</span></span><br><span class="line"><span class="comment">                int ret = fcntl(fd, F_DUPFD);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            - F_GETFL : 获取指定的文件描述符文件状态flag</span></span><br><span class="line"><span class="comment">              获取的flag和我们通过open函数传递的flag是一个东西。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            - F_SETFL : 设置文件描述符文件状态flag</span></span><br><span class="line"><span class="comment">              必选项：O_RDONLY, O_WRONLY, O_RDWR 不可以被修改</span></span><br><span class="line"><span class="comment">              可选性：O_APPEND, O)NONBLOCK</span></span><br><span class="line"><span class="comment">                O_APPEND 表示追加数据</span></span><br><span class="line"><span class="comment">                NONBLOK 设置成非阻塞</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        阻塞和非阻塞：描述的是函数调用的行为。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.复制文件描述符</span></span><br><span class="line">    <span class="comment">// int fd = open(&quot;1.txt&quot;, O_RDONLY);</span></span><br><span class="line">    <span class="comment">// int ret = fcntl(fd, F_DUPFD);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.修改或者获取文件状态flag</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;1.txt&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取文件描述符状态flag</span></span><br><span class="line">    <span class="type">int</span> flag = fcntl(fd, F_GETFL);</span><br><span class="line">    <span class="keyword">if</span>(flag == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fcntl&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    flag |= O_APPEND;   <span class="comment">// flag = flag 按位或 O_APPEND</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改文件描述符状态的flag，给flag加入O_APPEND这个标记</span></span><br><span class="line">    <span class="type">int</span> ret = fcntl(fd, F_SETFL, flag);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fcntl&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> * str = <span class="string">&quot;nihao&quot;</span>;</span><br><span class="line">    write(fd, str, <span class="built_in">strlen</span>(str));</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<hr>
<h2 id="7-进程"><a href="#7-进程" class="headerlink" title="7. 进程"></a>7. 进程</h2><h3 id="7-1进程概述"><a href="#7-1进程概述" class="headerlink" title="7.1进程概述"></a>7.1进程概述</h3><h4 id="7-1-1-程序与进程"><a href="#7-1-1-程序与进程" class="headerlink" title="7.1.1 程序与进程"></a>7.1.1 程序与进程</h4><ul>
<li><p>程序占用磁盘资源，但不占用CPU和内存，进程占用CPU和内存，但不占用磁盘。程序是包含一系列信息的文件，这些信息描述了如何在运行时创建一个进程:</p>
<ul>
<li><strong>二进制格式标识</strong>:每个程序文件都包含用于描述可执行文件格式的元信息。内核利用此信息来解释文件中的其他信息。(ELF可执行连接格式)</li>
<li>**机器语言指令:**对程序算法进行编码。</li>
<li>**程序入口地址:**标识程序开始执行时的起始指令位置。</li>
<li>**数据:**程序文件包含的变量初始值和程序使用的字面量值(比如字符串)</li>
<li>**符号表及重定位表:**描述程序中函数和变量的位置及名称。这些表格有多重用途，其中包括调试和运行时的符号解析(动态链接)</li>
<li>**共享库和动态链接信息:**程序文件所包含的一些字段，列出了程序运行时需要使用的共享库，以及加载共享库的动态连接器的路径名</li>
<li>**其他信息:**程序文件还包含许多其他信息，用以描述如何创建进程</li>
</ul>
</li>
<li><p>进程是正在运行的程序的实例。是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。</p>
</li>
<li><p>可以用一个程序来创建多个进程，进程是由内核定义的<font color='red'>抽象实体</font>，并为该实体分配用以执行程序的各项系统资源。从内核的角度看，进程由用户内存空间和一系列内核数据结构组成，其中<font color='blue'>用户内存空间包含了程序代码及代码所使用的变量，而内核数据结构则用于维护进程状态信息。</font>记录在内核数据结构中的信息包括许多与进程相关的标识号(IDs)、虚拟内存表、打开文件的描述符表、信号传递及处理的有关信息、进程资源使用及限制、当前工作目录和大量的其他信息。</p>
</li>
</ul>
<h4 id="7-1-2-单道、多道程序设计"><a href="#7-1-2-单道、多道程序设计" class="headerlink" title="7.1.2 单道、多道程序设计"></a>7.1.2 单道、多道程序设计</h4><ul>
<li>单道程序，即在计算机内存中只允许一个的程序运行。</li>
<li>多道程序设计技术是在计算机内存中同时存放几道相互独立的程序，使它们在管理程序控制下，<font color='red'><strong>相互穿插运行</strong></font>，两个或两个以上程序在计算机系统中同处于开始到结束之间的状态，这些程序共享计算机系统资源。**<font color='red'>引入多道程序设计技术的根本目的是为了提高 CPU 的利用率。</font>**</li>
<li>对于一个单CPU 系统来说，程序同时处于运行状态只是一种宏观上的概念，他们虽、然都已经开始运行，但<font color='red'>就微观而言，任意时刻，CPU上运行的程序只有一个。</font></li>
<li>在多道程序设计模型中，多个进程轮流使用CPU。而当下常见CPU为纳秒级，1秒可以执行大约 10 亿条指令。由于人眼的反应速度是毫秒级，所以看似同时在运行</li>
</ul>
<h4 id="7-1-3-时间片"><a href="#7-1-3-时间片" class="headerlink" title="7.1.3 时间片"></a>7.1.3 时间片</h4><ul>
<li><p>时间片(timeslice)又称为“量子(quantum)”或“处理器片(processor slice)是<font color='red'>操作系统分配给每个正在运行的进程微观上的一段CPU时间。</font>事实上，虽然一台计算机通常可能有多个 CPU，但是同一个CPU 永远不可能真正地同时运行多个任务。在只考虑一个 CPU 的情况下，这些进程“看起来像”同时运行的，实则是轮番穿插地运行由于时间片通常很短(在inux上为5ms-800ms)，用户不会感觉到。</p>
</li>
<li><p><font color='red'>时间片由操作系统内核的调度程序分配给每个进程。</font>首先，内核会给每个进程分配相等的初始时间片，然后每个进程轮番地执行相应的时间，当所有进程都处于时间片耗尽的状态时，内核会重新为每个进程计算并分配时间片，如此往复。</p>
</li>
</ul>
<h4 id="7-1-4-并行和并发"><a href="#7-1-4-并行和并发" class="headerlink" title="7.1.4 并行和并发"></a>7.1.4 并行和并发</h4><ul>
<li>**并行(paralle1):**指在同一时刻，有多条指令在多个处理器上同时执行。</li>
<li>**并发(concurrency):**指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的只是把时间分成若干段，使多个进程快速交替的执行。</li>
</ul>
<p> <img src="https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240423204853427.png" alt="image-20240423204853427"></p>
<ul>
<li><p>并发是两个队列交替使用一台咖啡机。<br>并行是两个队列同时使用两台咖啡机。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240423205118283.png" alt="image-20240423205118283"></p>
</li>
</ul>
<h4 id="7-1-5-进程控制块PCB-x2F-进程描述符表"><a href="#7-1-5-进程控制块PCB-x2F-进程描述符表" class="headerlink" title="7.1.5 进程控制块PCB&#x2F;进程描述符表"></a>7.1.5 进程控制块PCB&#x2F;进程描述符表</h4><ul>
<li>为了管理进程，内核必须对每个进程所做的事情进行清楚的描述。内核为每个进程分配一个 PCB(Processing Control Block)进程控制块，维护进程相关的信息，Linux内核的进程控制块是 <strong>task struct 结构体</strong></li>
<li>在&#x2F;usr&#x2F;src&#x2F;linux-headers-xxx&#x2F;include&#x2F;linux&#x2F;sched.h 文件中可以看 struct task struct 结构体定义。其内部成员有很多，我们只需要掌握以部分即可:<ul>
<li>进程id:系统中每个进程有唯一的id，用pidt类型表示，其实就是一个非负整数</li>
<li>进程的状态:有就绪、运行、挂起、停止等状态</li>
<li>进程切换时需要保存和恢复的一些CPU寄存器</li>
<li>描述虚拟地址空间的信息</li>
<li>描述控制终端的信息</li>
<li>当前工作目录(Current Working Directory)</li>
<li>umask 掩码</li>
<li>文件描述符表，包含很多指向 file 结构体的指针</li>
<li>和信号相关的信息</li>
<li>用户 id 和组 id</li>
<li>会话(Session)和进程组</li>
<li>进程可以使用的资源上限(Resource Limit)</li>
</ul>
</li>
</ul>
<h3 id="7-2-进程状态转换"><a href="#7-2-进程状态转换" class="headerlink" title="7.2 进程状态转换"></a>7.2 进程状态转换</h3><h4 id="7-2-1-进程的状态"><a href="#7-2-1-进程的状态" class="headerlink" title="7.2.1 进程的状态"></a>7.2.1 进程的状态</h4><ul>
<li>进程状态反映进程执行过程的变化。这些状态随着进程的执行和外界条件的变化而转换在三态模型中，进程状态分为三个基本状态，即就绪态，运行态，阻塞态。在五态模型中，进程分为新建态、就绪态，运行态，阻塞态，终止态。<ul>
<li>运行态:进程占有处理器正在运行</li>
<li>就绪态:进程具备运行条件，等待系统分配处理器以便运行。当进程已分配到除CPU以外的所有必要资源后，只要再获得CPU，便可立即执行。在一个系统中处于就绪状态的进程可能有多个，通常将它们排成一个队列，称为就绪队列</li>
<li>阻塞态:又称为等待(wait)态或睡眠(sleep)态，指进程不具备运行条件，正在等待某个事件的完成</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240423212620638.png" alt="image-20240423212620638"></p>
<p> <img src="https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240423214654291.png" alt="image-20240423214654291"></p>
<h4 id="7-2-2-进程相关命令"><a href="#7-2-2-进程相关命令" class="headerlink" title="7.2.2 进程相关命令"></a>7.2.2 进程相关命令</h4><ul>
<li><strong>查看进程</strong><br><code>ps aux/ajx</code><br>a: 显示终端上的所有进程，包括其他用户的进程<br>u: 显示进程的详细信息<br>x: 显示没有控制终端的进程<br> j: 列出与作业控制相关的信息</li>
</ul>
<p>​	<code>tty</code>——查看当前进程对应的终端</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*STAT参数意义</span><br><span class="line">	D			不可中断 Uninterruptible(usually IO)</span><br><span class="line">	R			正在运行，或在队列中的进程</span><br><span class="line">	S(大写)	   处于休眠状态</span><br><span class="line">	T			停止或被追踪</span><br><span class="line">	Z			僵尸进程</span><br><span class="line">	W			进入内存交换(从内核2.6开始无效)</span><br><span class="line">	X			死掉的进程</span><br><span class="line">	&lt;			高优先级</span><br><span class="line">	N			低优先级</span><br><span class="line">	s			包含子进程</span><br><span class="line">	+			位于前台的进程组</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>实时显示进程动态</strong><br><code>top</code><br>可以在使用 top 命令时加上 -d 来指定显示信息更新的时间	间隔，在 top 命令执行后，可以按以下按键对显示的结果	进行排序:<br>    M		根据内存使用量排序<br>    P  		根据CPU 占有率排序<br>    T		  根据进程运行时间长短排序<br>    U		 根据用户名来筛选进程<br>    K		  输入指定的 PID 杀死进程<ul>
<li><strong>杀死进程</strong><ol>
<li>kill [-signal]pid</li>
<li>kill -l 列出所有信号</li>
<li>kill-SIGKILL 进程ID         强制杀死进程</li>
<li>kill -9 进程ID                     强制杀死进程</li>
<li>killall name 根据进程名杀死进程</li>
</ol>
</li>
</ul>
</li>
</ul>
<p><code>./xx.xxx(可执行程序) &amp;</code>——在后台运行程序</p>
<h4 id="7-2-3进程号和相关函数"><a href="#7-2-3进程号和相关函数" class="headerlink" title="7.2.3进程号和相关函数"></a>7.2.3进程号和相关函数</h4><ul>
<li>每个进程都由进程号来标识，其类型为pidt(整型)，进程号的范围:0~32767进程号总是唯一的，但可以重用。当一个进程终止后，其进程号就可以再次使用。</li>
<li>任何进程(除 init 进程)都是由另一个进程创建，该进程称为被创建进程的父进程对应的进程号称为父进程号(PPID)</li>
<li>进程组是一个或多个进程的集合。他们之间相互关联，进程组可以接收同一终端的各种信号，关联的进程有一个进程组号(PGID)。默认情况下，当前的进程号会当做当前的进程组号</li>
<li>进程号和进程组相关函数:<ul>
<li>pid t getpid(void);</li>
<li>pid t getppid(void);</li>
<li>pid t getpgid(pid t pid);</li>
</ul>
</li>
</ul>
<h3 id="7-3-进程创建"><a href="#7-3-进程创建" class="headerlink" title="7.3 进程创建"></a>7.3 进程创建</h3><p>系统允许一个进程创建新进程，新进程即为子进程，子进程还可以创建新的子进程，形成G进程树结构模型。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"> <span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>返回值:<br>    成功:子进程中返回 0，父进程中返回子进程ID</p>
<p>​	失败:返回 -1</p>
<p>失败的两个主要原因:</p>
<ol>
<li>当前系统的进程数已经达到了系统规定的上限，这时errno的值被设置为 EAGAIN</li>
<li>系统内存不足，这时errno 的值被设置为NOMEM</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    pid_t fork(void);</span></span><br><span class="line"><span class="comment">        函数的作用：用于创建子进程。</span></span><br><span class="line"><span class="comment">        返回值：</span></span><br><span class="line"><span class="comment">            fork()的返回值会返回两次。一次是在父进程中，一次是在子进程中。</span></span><br><span class="line"><span class="comment">            在父进程中返回创建的子进程的ID,</span></span><br><span class="line"><span class="comment">            在子进程中返回0</span></span><br><span class="line"><span class="comment">            如何区分父进程和子进程：通过fork的返回值。</span></span><br><span class="line"><span class="comment">            在父进程中返回-1，表示创建子进程失败，并且设置errno</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        父子进程之间的关系：</span></span><br><span class="line"><span class="comment">        区别：</span></span><br><span class="line"><span class="comment">            1.fork()函数的返回值不同</span></span><br><span class="line"><span class="comment">                父进程中: &gt;0 返回的子进程的ID</span></span><br><span class="line"><span class="comment">                子进程中: =0</span></span><br><span class="line"><span class="comment">            2.pcb中的一些数据</span></span><br><span class="line"><span class="comment">                当前的进程的id pid</span></span><br><span class="line"><span class="comment">                当前的进程的父进程的id ppid</span></span><br><span class="line"><span class="comment">                信号集</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        共同点：</span></span><br><span class="line"><span class="comment">            某些状态下：子进程刚被创建出来，还没有执行任何的写数据的操作</span></span><br><span class="line"><span class="comment">                - 用户区的数据</span></span><br><span class="line"><span class="comment">                - 文件描述符表</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        父子进程对变量是不是共享的？</span></span><br><span class="line"><span class="comment">            - 刚开始的时候，是一样的，共享的。如果修改了数据，不共享了。</span></span><br><span class="line"><span class="comment">            - 读时共享（子进程被创建，两个进程没有做任何的写的操作），写时拷贝。</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是父进程还是子进程</span></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// printf(&quot;pid : %d\n&quot;, pid);</span></span><br><span class="line">        <span class="comment">// 如果大于0，返回的是创建的子进程的进程号，当前是父进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am parent process, pid : %d, ppid : %d\n&quot;</span>, getpid(), getppid());</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent num : %d\n&quot;</span>, num);</span><br><span class="line">        num += <span class="number">10</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent num += 10 : %d\n&quot;</span>, num);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 当前是子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am child process, pid : %d, ppid : %d\n&quot;</span>, getpid(),getppid());</span><br><span class="line">       </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child num : %d\n&quot;</span>, num);</span><br><span class="line">        num += <span class="number">100</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child num += 100 : %d\n&quot;</span>, num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for循环</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i : %d , pid : %d\n&quot;</span>, i , getpid());</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">实际上，更准确来说，Linux 的 fork() 使用是通过写时拷贝 (copy- on-write) 实现。</span></span><br><span class="line"><span class="comment">写时拷贝是一种可以推迟甚至避免拷贝数据的技术。</span></span><br><span class="line"><span class="comment">内核此时并不复制整个进程的地址空间，而是让父子进程共享同一个地址空间。</span></span><br><span class="line"><span class="comment">只用在需要写入的时候才会复制地址空间，从而使各个进行拥有各自的地址空间。</span></span><br><span class="line"><span class="comment">也就是说，资源的复制是在需要写入的时候才会进行，在此之前，只有以只读方式共享。</span></span><br><span class="line"><span class="comment">注意：fork之后父子进程共享文件，</span></span><br><span class="line"><span class="comment">fork产生的子进程与父进程相同的文件文件描述符指向相同的文件表，引用计数增加，共享文件偏移指针。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="7-4-父子进程虚拟地址空间情况"><a href="#7-4-父子进程虚拟地址空间情况" class="headerlink" title="7.4 父子进程虚拟地址空间情况"></a>7.4 父子进程虚拟地址空间情况</h3><p><img src="https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240424124551272.png" alt="image-20240424124551272"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240424133741867.png" alt="image-20240424133741867"></p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//程序运行后的结果，父子进程中的num变量互不影响</span></span><br><span class="line">nowcoder@nowcoder:~/Linux/leeson18$ gcc fork.c -o fork</span><br><span class="line">nowcoder@nowcoder:~/Linux/leeson18$ ./fork</span><br><span class="line">i am parent process, pid : <span class="number">61840</span>, ppid : <span class="number">61802</span></span><br><span class="line">parent num : <span class="number">10</span></span><br><span class="line">parent num += <span class="number">10</span> : <span class="number">20</span></span><br><span class="line">i : <span class="number">0</span> , pid : <span class="number">61840</span></span><br><span class="line">i am child process, pid : <span class="number">61841</span>, ppid : <span class="number">61840</span></span><br><span class="line">child num : <span class="number">10</span></span><br><span class="line">child num += <span class="number">100</span> : <span class="number">110</span></span><br><span class="line">i : <span class="number">0</span> , pid : <span class="number">61841</span></span><br><span class="line">i : <span class="number">1</span> , pid : <span class="number">61841</span></span><br><span class="line">i : <span class="number">1</span> , pid : <span class="number">61840</span></span><br><span class="line">i : <span class="number">2</span> , pid : <span class="number">61841</span></span><br><span class="line">i : <span class="number">2</span> , pid : <span class="number">61840</span></span><br></pre></td></tr></table></figure>

<h3 id="7-5-父子进程关系及GBD多进程调试"><a href="#7-5-父子进程关系及GBD多进程调试" class="headerlink" title="7.5 父子进程关系及GBD多进程调试"></a>7.5 父子进程关系及GBD多进程调试</h3><h4 id="7-5-1-GBD多进程调试"><a href="#7-5-1-GBD多进程调试" class="headerlink" title="7.5.1 GBD多进程调试"></a>7.5.1 GBD多进程调试</h4><p>使用GDB 调试的时候，GDB 默认只能跟踪一个进程，可以在fork 函数调用之前，通过指令设置 GDB 调试工具跟踪父进程或者是跟踪子进程，<strong>默认跟踪父进程</strong>。<br><font color='orange'>设置调试父进程或者子进程</font>:<code>set follow-fork-mode [parent(默认)Ichild]</code></p>
<p><font color='orange'>设置调试模式</font>:set detach-on-fork[on | off]&#96;</p>
<p><font color='orange'>查看调试进程：</font><code>show follow-fork-mode</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(gdb) show follow-fork-mode</span><br><span class="line">Debugger response to a program call of fork or vfork is <span class="string">&quot;parent&quot;</span>.</span><br><span class="line">(gdb) <span class="built_in">set</span> follow-fork-mode <span class="title function_">child</span></span><br><span class="line"><span class="params">(gdb)</span> show follow-fork-mode</span><br><span class="line">Debugger response to a program call of fork or vfork is &quot;child&quot;.</span><br></pre></td></tr></table></figure>



<p>默认为 on，表示调试当前进程的时候，其它的进程继续运行，如果为f，调试当前进程的时候，其它进程被 GDB 挂起。<br><font color='orange'>查看调试的进程:</font><code> info inferiors</code></p>
<p><font color='orange'>切换当前调试的进程:</font><code>inferior id</code></p>
<p><font color='orange'>使进程脱离 GDB调试:</font><code>detach inferiors id</code></p>
<p><code>gdb 文件名</code>进入gdb调试</p>
<p><code>gdb l</code>查看代码</p>
<p><code>b 行数</code> 在某行打断点</p>
<p><code>i b</code>查看断点信息</p>
<p><code>r</code>运行程序</p>
<p><code>n</code>是单步调试</p>
<p><code>c</code>执行完剩下的代码</p>
<p>安装ubuntu16</p>
<h3 id="7-6-exec函数族"><a href="#7-6-exec函数族" class="headerlink" title="7.6 exec函数族"></a>7.6 exec函数族</h3><p>——像C++中的函数重载，是一系列功能相同或相似的函数</p>
<h4 id="7-6-1exec函数族介绍"><a href="#7-6-1exec函数族介绍" class="headerlink" title="7.6.1exec函数族介绍"></a>7.6.1exec函数族介绍</h4><ul>
<li>函数族的作用是<font color='blue'>根据指定的文件名找到可执行文件</font>，并用它来取代调用进程的exeC内容，换句话说，就是在调用进程内部执行一个可执行文件。</li>
<li>exec 函数族的函数执行成功后不会返回，因为调用进程的实体，包括代码段，数据段和堆栈等都已经被新的内容取代，只留下进程ID等一些表面上的信息仍保持原样颇有些神似“三十六计”中的“金蝉脱壳”。看上去还是旧的躯壳，却已经注入了新的灵魂。只有调用失败了，它们才会返回-1，从原程序的调用点接着往下执行。</li>
</ul>
<h4 id="7-6-2-函数族图解"><a href="#7-6-2-函数族图解" class="headerlink" title="7.6.2 函数族图解"></a>7.6.2 函数族图解</h4><p>内核区维护着当前进程的一些信息，比如id、状态、</p>
<p><img src="https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240425101754446.png" alt="image-20240425101754446"></p>
<h4 id="7-6-4-exec函数族"><a href="#7-6-4-exec函数族" class="headerlink" title="7.6.4 exec函数族"></a>7.6.4 exec函数族</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">execl</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path,<span class="type">const</span> <span class="type">char</span> *arg,...<span class="comment">/* (char *) NULL */</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">execlp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file,<span class="type">const</span> <span class="type">char</span> *arg,...<span class="comment">/* (char *)NULL */</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">execle</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path,<span class="type">const</span> <span class="type">char</span> *arg,...<span class="comment">/*,(char *)NULL, char* const envp[] */</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path,<span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execvp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file,<span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execvpe</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file,<span class="type">char</span> *<span class="type">const</span> argv[], <span class="type">char</span> *<span class="type">const</span> envp[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename,<span class="type">char</span> *<span class="type">const</span> argv[],<span class="type">char</span> *<span class="type">const</span> envp[])</span>;</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> (<span class="built_in">list</span>)		参数地址列表，以空指针结尾</span><br><span class="line">v(<span class="built_in">vector</span>)		存有各参数地址的指针数组的地址</span><br><span class="line">P(path)			按 PATH 环境变量指定的目录搜索可执行文件</span><br><span class="line">e(environment)	存有环境变量字符串地址的指针数组的地址e</span><br></pre></td></tr></table></figure>

<p><code>which 程序名</code>——查看程序所在目录</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* execl函数 </span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">    int execl(const char *path, const char *arg, ...);</span></span><br><span class="line"><span class="comment">        - 参数：</span></span><br><span class="line"><span class="comment">            - path:需要指定的执行的文件的路径或者名称</span></span><br><span class="line"><span class="comment">                a.out /home/nowcoder/a.out 推荐使用绝对路径</span></span><br><span class="line"><span class="comment">                ./a.out hello world</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            - arg:是执行可执行文件所需要的参数列表</span></span><br><span class="line"><span class="comment">                第一个参数一般没有什么作用，为了方便，一般写的是执行的程序的名称</span></span><br><span class="line"><span class="comment">                从第二个参数开始往后，就是程序执行所需要的的参数列表。</span></span><br><span class="line"><span class="comment">                参数最后需要以NULL结束（哨兵）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        - 返回值：</span></span><br><span class="line"><span class="comment">            只有当调用失败，才会有返回值，返回-1，并且设置errno</span></span><br><span class="line"><span class="comment">            如果调用成功，没有返回值。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个子进程，在子进程中执行exec函数族中的函数</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am parent process, pid : %d\n&quot;</span>,getpid());</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        execl(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;hello&quot;</span>,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//execl(&quot;/bin/ps&quot;, &quot;ps&quot;, &quot;aux&quot;, NULL);</span></span><br><span class="line">        <span class="comment">//perror(&quot;execl&quot;);</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am child process, pid : %d\n&quot;</span>, getpid());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i = %d, pid = %d\n&quot;</span>, i, getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//结果</span></span><br><span class="line">nowcoder@nowcoder:~/Linux/lesson19$ gcc execl.c -o execl</span><br><span class="line">nowcoder@nowcoder:~/Linux/lesson19$ ./execl</span><br><span class="line">i am parent process, pid : <span class="number">68644</span></span><br><span class="line">hello, world</span><br><span class="line">i = <span class="number">0</span>, pid = <span class="number">68644</span></span><br><span class="line">i = <span class="number">1</span>, pid = <span class="number">68644</span></span><br><span class="line">i = <span class="number">2</span>, pid = <span class="number">68644</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">    int execlp(const char *file, const char *arg, ... );</span></span><br><span class="line"><span class="comment">        - 会到环境变量中查找指定的可执行文件，如果找到了就执行，找不到就执行不成功。</span></span><br><span class="line"><span class="comment">        - 参数：</span></span><br><span class="line"><span class="comment">            - file:需要执行的可执行文件的文件名</span></span><br><span class="line"><span class="comment">                a.out</span></span><br><span class="line"><span class="comment">                ps</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            - arg:是执行可执行文件所需要的参数列表</span></span><br><span class="line"><span class="comment">                第一个参数一般没有什么作用，为了方便，一般写的是执行的程序的名称</span></span><br><span class="line"><span class="comment">                从第二个参数开始往后，就是程序执行所需要的的参数列表。</span></span><br><span class="line"><span class="comment">                参数最后需要以NULL结束（哨兵）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        - 返回值：</span></span><br><span class="line"><span class="comment">            只有当调用失败，才会有返回值，返回-1，并且设置errno</span></span><br><span class="line"><span class="comment">            如果调用成功，没有返回值。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        int execv(const char *path, char *const argv[]);</span></span><br><span class="line"><span class="comment">        argv是需要的参数的一个字符串数组</span></span><br><span class="line"><span class="comment">        char * argv[] = &#123;&quot;ps&quot;, &quot;aux&quot;, NULL&#125;;</span></span><br><span class="line"><span class="comment">        execv(&quot;/bin/ps&quot;, argv);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        int execve(const char *filename, char *const argv[], char *const envp[]);</span></span><br><span class="line"><span class="comment">        char * envp[] = &#123;&quot;/home/nowcoder&quot;, &quot;/home/bbb&quot;, &quot;/home/aaa&quot;&#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个子进程，在子进程中执行exec函数族中的函数</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am parent process, pid : %d\n&quot;</span>,getpid());</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        execlp(<span class="string">&quot;ps&quot;</span>, <span class="string">&quot;ps&quot;</span>, <span class="string">&quot;aux&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am child process, pid : %d\n&quot;</span>, getpid());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i = %d, pid = %d\n&quot;</span>, i, getpid());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-7-进程控制"><a href="#7-7-进程控制" class="headerlink" title="7.7 进程控制"></a>7.7 进程控制</h3><h4 id="7-7-1进程退出exit"><a href="#7-7-1进程退出exit" class="headerlink" title="7.7.1进程退出exit"></a>7.7.1进程退出exit</h4><p><img src="https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240425124936108.png" alt="image-20240425124936108"></p>
<p><code>status</code>是进程退出时的一个状态信息。父进程回收子进程资源的时候可以获取到。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">    void exit(int status);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">    void _exit(int status);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    status参数：是进程退出时的一个状态信息。父进程回收子进程资源的时候可以获取到。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;world&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// exit(0);</span></span><br><span class="line">    _exit(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-7-2孤儿进程"><a href="#7-7-2孤儿进程" class="headerlink" title="7.7.2孤儿进程"></a>7.7.2孤儿进程</h4><ul>
<li>父进程运行结束，但子进程还在运行(未运行结束)，这样的子进程就称为<strong>孤儿进程</strong>(Orphan Process)</li>
<li>每当出现一个孤儿进程的时候，内核就把孤儿进程的父进程设置为init，而init进程会循环地 wait()它的已经退出的子进程。这样，当一个孤儿进程凄凉地结束了其生命周期的时候，init进程就会代表党和政府出面处理它的一切善后工作。</li>
<li>因此孤儿进程并不会有什么危害。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240425133450437.png" alt="image-20240425133450437"></p>
<h4 id="7-7-3僵尸进程"><a href="#7-7-3僵尸进程" class="headerlink" title="7.7.3僵尸进程"></a>7.7.3僵尸进程</h4><ul>
<li>每个进程结束之后，都会释放自己地址空间中的用户区数据，内核区的PCB没有办法自己释放掉，需要父进程去释放。</li>
<li>进程终止时，父进程尚未回收，子进程残留资源(PCB)存放于内核中，变成僵尸(Zombie)进程。</li>
<li>僵尸进程不能被 kill -9 杀死。</li>
<li>这样就会导致一个问题，如果父进程不调用wait()或 waitpid()的话，那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程，此即为僵尸进程的危害，应当避免。</li>
</ul>
<p>治理僵尸进程：</p>
<p>​	杀死父进程 <code>kill -9 进程号</code></p>
<h3 id="7-8-wait函数"><a href="#7-8-wait函数" class="headerlink" title="7.8 wait函数"></a>7.8 wait函数</h3><h4 id="7-8-1进程回收"><a href="#7-8-1进程回收" class="headerlink" title="7.8.1进程回收"></a>7.8.1进程回收</h4><ul>
<li>在每个进程退出的时候，内核释放该进程所有的资源、包括打开的文件、占用的内存等。但是仍然为其保留一定的信息，这些信息主要主要指进程控制块PCB的信息包括进程号、退出状态、运行时间等)</li>
<li>父进程可以通过调用wait或waitpid得到它的退出状态同时彻底清除掉这个进程。</li>
<li>wait()和 waitpid()函数的功能一样，区别在于，wait()函数会阻塞waitpid()可以设置不阻塞，waitpid()还可以指定等待哪个子进程结束</li>
<li>注意:一次wait或waitpid调用只能清理一个子进程，清理多个子进程应使用循环。</li>
</ul>
<h4 id="7-8-2退出信息相关函数"><a href="#7-8-2退出信息相关函数" class="headerlink" title="7.8.2退出信息相关函数"></a>7.8.2退出信息相关函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">WIFEXITED(status)非<span class="number">0</span>，进程正常退出</span><br><span class="line">WEXITSTATUS(statu)如果上宏为真，获取进程退出的状态(<span class="built_in">exit</span>的参数)</span><br><span class="line"></span><br><span class="line">WIFSIGNALED(status)非<span class="number">0</span>，进程异常终止</span><br><span class="line">WTERMSIG(status)如果上宏为真，获取使进程终止的信号编号</span><br><span class="line"></span><br><span class="line">WIFSTOPPED(status)非<span class="number">0</span>，进程处于暂停状态</span><br><span class="line">WSTOPSIG(status)如果上宏为真，获取使进程暂停的信号的编号</span><br><span class="line">WIFCONTINUED(status)非<span class="number">0</span>，进程暂停后已经继续运行</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;sys/wait.h&gt;</span></span><br><span class="line"><span class="comment">    pid_t wait(int *wstatus);</span></span><br><span class="line"><span class="comment">        功能：等待任意一个子进程结束，如果任意一个子进程结束了，次函数会回收子进程的资源。</span></span><br><span class="line"><span class="comment">        参数：int *wstatus</span></span><br><span class="line"><span class="comment">            进程退出时的状态信息，传入的是一个int类型的地址，传出参数。</span></span><br><span class="line"><span class="comment">        返回值：</span></span><br><span class="line"><span class="comment">            - 成功：返回被回收的子进程的id</span></span><br><span class="line"><span class="comment">            - 失败：-1 (所有的子进程都结束，调用函数失败)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    调用wait函数的进程会被挂起（阻塞），直到它的一个子进程退出或者收到一个不能被忽略的信号时才被唤醒（相当于继续往下执行）</span></span><br><span class="line"><span class="comment">    如果没有子进程了，函数立刻返回，返回-1；如果子进程都已经结束了，也会立即返回，返回-1.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有一个父进程，创建5个子进程（兄弟）</span></span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建5个子进程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;<span class="comment">//防止产生孙子进程</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;parent, pid = %d\n&quot;</span>, getpid());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// int ret = wait(NULL);</span></span><br><span class="line">            <span class="type">int</span> st;</span><br><span class="line">            <span class="type">int</span> ret = wait(&amp;st);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;			<span class="comment">//没有子进程回收就break</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(WIFEXITED(st)) &#123;</span><br><span class="line">                <span class="comment">// 是不是正常退出</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;退出的状态码：%d\n&quot;</span>, WEXITSTATUS(st));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(WIFSIGNALED(st)) &#123;</span><br><span class="line">                <span class="comment">// 是不是异常终止</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;被哪个信号干掉了：%d\n&quot;</span>, WTERMSIG(st));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child die, pid = %d\n&quot;</span>, ret);</span><br><span class="line"></span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">         <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child, pid = %d\n&quot;</span>,getpid());    </span><br><span class="line">            sleep(<span class="number">1</span>);       </span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// exit(0)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-9-waitpid函数"><a href="#7-9-waitpid函数" class="headerlink" title="7.9 waitpid函数"></a>7.9 waitpid函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line">    <span class="type">pid_t</span> <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> *wstatus, <span class="type">int</span> options)</span>;</span><br><span class="line">        功能：回收指定进程号的子进程，可以设置是否阻塞。</span><br><span class="line">        参数：</span><br><span class="line">            - pid:</span><br><span class="line">                pid &gt; <span class="number">0</span> : 某个子进程的pid</span><br><span class="line">                pid = <span class="number">0</span> : 回收当前进程组的所有子进程    </span><br><span class="line">                pid = <span class="number">-1</span> : 回收所有的子进程，相当于 wait()  （最常用）</span><br><span class="line">                pid &lt; <span class="number">-1</span> : 某个进程组的组id的绝对值，回收指定进程组中的子进程</span><br><span class="line">            - options：设置阻塞或者非阻塞</span><br><span class="line">                <span class="number">0</span> : 阻塞</span><br><span class="line">                WNOHANG : 非阻塞</span><br><span class="line">            - 返回值：</span><br><span class="line">                &gt; <span class="number">0</span> : 返回子进程的id</span><br><span class="line">                = <span class="number">0</span> : options=WNOHANG, 表示还有子进程活着</span><br><span class="line">                = <span class="number">-1</span> ：错误，或者没有子进程了</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有一个父进程，创建5个子进程（兄弟）</span></span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建5个子进程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;parent, pid = %d\n&quot;</span>, getpid());</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> st;</span><br><span class="line">            <span class="comment">// int ret = waitpid(-1, &amp;st, 0);</span></span><br><span class="line">            <span class="type">int</span> ret = waitpid(<span class="number">-1</span>, &amp;st, WNOHANG);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 说明还有子进程存在</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(WIFEXITED(st)) &#123;</span><br><span class="line">                    <span class="comment">// 是不是正常退出</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;退出的状态码：%d\n&quot;</span>, WEXITSTATUS(st));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(WIFSIGNALED(st)) &#123;</span><br><span class="line">                    <span class="comment">// 是不是异常终止</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;被哪个信号干掉了：%d\n&quot;</span>, WTERMSIG(st));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;child die, pid = %d\n&quot;</span>, ret);</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">         <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child, pid = %d\n&quot;</span>,getpid());    </span><br><span class="line">            sleep(<span class="number">1</span>);       </span><br><span class="line">         &#125;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-进程间通信IPC"><a href="#8-进程间通信IPC" class="headerlink" title="8 进程间通信IPC"></a>8 进程间通信IPC</h2><h3 id="8-1进程间通信IPC（进程与进程之间收发数据的过程）"><a href="#8-1进程间通信IPC（进程与进程之间收发数据的过程）" class="headerlink" title="8.1进程间通信IPC（进程与进程之间收发数据的过程）"></a>8.1进程间通信IPC（进程与进程之间收发数据的过程）</h3><ol>
<li>进程间通信的方式有哪几种</li>
<li>进程间通信某个方式的具体原理</li>
</ol>
<ul>
<li>进程是一个独立的资源分配单元，不同进程(这里所说的进程通常指的是用户进程)之间的资源是独立的，没有关联，不能在一个进程中直接访问另一个进程的资源。</li>
<li>但是，进程不是孤立的，不同的进程需要进行信息的交互和状态的传递等，因此需要进程间通信(<strong>IPC</strong>:<font color='red'>Inter Processes Communication)。</font></li>
<li>进程间通信的目的:<ul>
<li>数据传输:一个进程需要将它的数据发送给另一个进程。</li>
<li>通知事件:一个进程需要向另一个或一组进程发送消息，通知它(它们)发生了某种事件(如进程终止时要通知父进程)</li>
<li>资源共享:多个进程之间共享同样的资源。为了做到这一点，需要内核提供互斥和同步机制。<ul>
<li>异步可能会带来隐私问题</li>
</ul>
</li>
<li>进程控制:有些进程希望完全控制另一个进程的执行(如Debug进程)，此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变</li>
</ul>
</li>
<li>GUI——图形用户接口，IDE——集成开发环境，API——应用程序接口</li>
</ul>
<h4 id="Linux进程间通信的方式"><a href="#Linux进程间通信的方式" class="headerlink" title="Linux进程间通信的方式"></a>Linux进程间通信的方式</h4><p><img src="https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240506221736196.png" alt="1"></p>
<h3 id="8-2-匿名管道概述"><a href="#8-2-匿名管道概述" class="headerlink" title="8.2 匿名管道概述"></a>8.2 匿名管道概述</h3><ul>
<li>管道也叫无名(匿名)管道，它是是UNIX系统IPC(进程间通信)的最古老形式，所有的 UNIX 系统都支持这种通信机制。</li>
<li>统计一个目录中文件的数目命令:<code>ls | wc -l</code>，为了执行该命令，<code>shell </code>创建了两个进程来分别执行<code>ls</code>和<code>wc</code>。<br><img src="https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240506222147361.png" alt="image-20240506222147361"></li>
</ul>
<h4 id="💥管道的特点"><a href="#💥管道的特点" class="headerlink" title="💥管道的特点"></a>💥管道的特点</h4><ul>
<li><p>管道其实是一个在内核内存中维护的缓冲器，这个缓冲器的存储能力是有限的，不同的、操作系统大小不一定相同。</p>
</li>
<li><p>管道拥有文件的特质:读操作、写操作，匿名管道没有文件实体，有名管道有文件实体但不存储数据。可以按照操作文件的方式对管道进行操作。</p>
</li>
<li><p>一个管道是一个字节流，使用管道时不存在消息或者消息边界的概念，<font color='red'>从管道读取数据的进程可以读取任意大小的数据块</font>，而不管写入进程写入管道的数据块的大小是多少。</p>
</li>
<li><p>通过管道传递的数据是顺序的，从管道中读取出来的字节的顺序和它们被写入管道的顺序是完全一样的。</p>
</li>
<li><p>在管道中的数据的传递方向是单向的，一端用于写入，一端用于读取，<strong>管道是半双工的。</strong></p>
</li>
<li><p>从管道读数据是一次性操作，数据一旦被读走，它就从管道中被抛弃，释放空间以便写更多的数据，在管道中无法使用 1seek()来随机的访问数据。</p>
</li>
<li><p>匿名管道只能在具有公共祖先的进程(父进程与子进程，或者两个兄弟进程，具有亲缘关系)之间使用。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240507100016172.png" alt="image-20240507100016172"></p>
</li>
<li><p>管道的数据结构一般是循环队列，通过逻辑手段实现。</p>
</li>
<li><p><img src="https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240507101939000.png" alt="image-20240507101939000"></p>
</li>
</ul>
<h4 id="匿名管道的使用"><a href="#匿名管道的使用" class="headerlink" title="匿名管道的使用"></a>匿名管道的使用</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建匿名管道</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">pipe</span><span class="params">(<span class="type">int</span> pipefd[<span class="number">2</span>])</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查看管道缓冲大小命令</span></span><br><span class="line">	ulimit -a</span><br><span class="line">        </span><br><span class="line"><span class="comment">//查看管道缓冲大小函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">long</span> <span class="title function_">fpathconf</span><span class="params">(<span class="type">int</span> fd,<span class="type">int</span> name)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="8-3-父子进程通过匿名管道通信"><a href="#8-3-父子进程通过匿名管道通信" class="headerlink" title="8.3 父子进程通过匿名管道通信"></a>8.3 父子进程通过匿名管道通信</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">    int pipe(int pipefd[2]);</span></span><br><span class="line"><span class="comment">        功能：创建一个匿名管道，用来进程间通信。</span></span><br><span class="line"><span class="comment">        参数：int pipefd[2] 这个数组是一个传出参数。</span></span><br><span class="line"><span class="comment">            pipefd[0] 对应的是管道的读端</span></span><br><span class="line"><span class="comment">            pipefd[1] 对应的是管道的写端</span></span><br><span class="line"><span class="comment">        返回值：</span></span><br><span class="line"><span class="comment">            成功 0</span></span><br><span class="line"><span class="comment">            失败 -1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    管道默认是阻塞的：如果管道中没有数据，read阻塞，如果管道满了，write阻塞</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    注意：匿名管道只能用于具有关系的进程之间的通信（父子进程，兄弟进程）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建匿名管道</span></span><br><span class="line"><span class="comment">// 子进程发送数据给父进程，父进程读取到数据输出</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span><span class="comment">//fork函数子进程</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在fork之前创建管道</span></span><br><span class="line">    <span class="type">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> ret = pipe(pipefd);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am parent process, pid : %d\n&quot;</span>, getpid());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭写端</span></span><br><span class="line">        close(pipefd[<span class="number">1</span>]);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从管道的读取端读取数据</span></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> len = read(pipefd[<span class="number">0</span>], buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;parent recv : %s, pid : %d\n&quot;</span>, buf, getpid());</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 向管道中写入数据</span></span><br><span class="line">            <span class="comment">//char * str = &quot;hello,i am parent&quot;;</span></span><br><span class="line">            <span class="comment">//write(pipefd[1], str, strlen(str));</span></span><br><span class="line">            <span class="comment">//sleep(1);</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am child process, pid : %d\n&quot;</span>, getpid());</span><br><span class="line">        <span class="comment">// 关闭读端</span></span><br><span class="line">        close(pipefd[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 向管道中写入数据</span></span><br><span class="line">            <span class="type">char</span> * str = <span class="string">&quot;hello,i am child&quot;</span>;</span><br><span class="line">            write(pipefd[<span class="number">1</span>], str, <span class="built_in">strlen</span>(str));</span><br><span class="line">            <span class="comment">//sleep(1);</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// int len = read(pipefd[0], buf, sizeof(buf));</span></span><br><span class="line">            <span class="comment">// printf(&quot;child recv : %s, pid : %d\n&quot;, buf, getpid());</span></span><br><span class="line">            <span class="comment">// bzero(buf, 1024);</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="匿名管道通信案例"><a href="#匿名管道通信案例" class="headerlink" title="匿名管道通信案例"></a>匿名管道通信案例</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    实现 ps aux | grep xxx 父子进程间通信</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    子进程： ps aux, 子进程结束后，将数据发送给父进程</span></span><br><span class="line"><span class="comment">    父进程：获取到数据，过滤</span></span><br><span class="line"><span class="comment">    pipe()</span></span><br><span class="line"><span class="comment">    execlp()</span></span><br><span class="line"><span class="comment">    子进程将标准输出 stdout_fileno 重定向到管道的写端。  dup2</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个管道</span></span><br><span class="line">    <span class="type">int</span> fd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> ret = pipe(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="comment">// 关闭写端</span></span><br><span class="line">        close(fd[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// 从管道中读取</span></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> len = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>((len = read(fd[<span class="number">0</span>], buf, <span class="keyword">sizeof</span>(buf) - <span class="number">1</span>)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 过滤数据输出</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, buf);</span><br><span class="line">            <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">1024</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        <span class="comment">// 关闭读端</span></span><br><span class="line">        close(fd[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 文件描述符的重定向 stdout_fileno -&gt; fd[1]</span></span><br><span class="line">        dup2(fd[<span class="number">1</span>], STDOUT_FILENO);</span><br><span class="line">        <span class="comment">// 执行 ps aux</span></span><br><span class="line">        execlp(<span class="string">&quot;ps&quot;</span>, <span class="string">&quot;ps&quot;</span>, <span class="string">&quot;aux&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">        perror(<span class="string">&quot;execlp&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-4-管道的读写特点和管道设置为非阻塞"><a href="#8-4-管道的读写特点和管道设置为非阻塞" class="headerlink" title="8.4 管道的读写特点和管道设置为非阻塞"></a>8.4 管道的读写特点和管道设置为非阻塞</h3><h4 id="管道的读写特点："><a href="#管道的读写特点：" class="headerlink" title="管道的读写特点："></a>管道的读写特点：</h4><p>使用管道时，需要注意以下几种特殊的情况（假设都是阻塞I&#x2F;O操作）<br>1.所有的指向管道写端的文件描述符都关闭了（管道写端引用计数为0），有进程从管道的读端<br>读数据，那么管道中剩余的数据被读取以后，再次read会返回0，就像读到文件末尾一样。</p>
<p>2.如果有指向管道写端的文件描述符没有关闭（管道的写端引用计数大于0），而持有管道写端的进程<br>也没有往管道中写数据，这个时候有进程从管道中读取数据，那么管道中剩余的数据被读取后，<br>再次read会阻塞，直到管道中有数据可以读了才读取数据并返回。</p>
<p>3.如果所有指向管道读端的文件描述符都关闭了（管道的读端引用计数为0），这个时候有进程<br>向管道中写数据，那么该进程会收到一个<strong>信号SIGPIPE, 通常会导致进程异常终止</strong>。</p>
<p>4.如果有指向管道读端的文件描述符没有关闭（管道的读端引用计数大于0），而持有管道读端的进程<br>也没有从管道中读数据，这时有进程向管道中写数据，那么在管道被写满的时 候再次write会阻塞，<br>直到管道中有空位置才能再次写入数据并返回。</p>
<p>总结：<br><strong>读管道：</strong><br>        管道中有数据，read返回实际读到的字节数。<br>        管道中无数据：<br>            写端被全部关闭，read返回0（相当于读到文件的末尾）<br>            写端没有完全关闭，read阻塞等待</p>
<p><strong>写管道：</strong><br>    管道读端全部被关闭，进程异常终止（进程收到SIGPIPE信号）<br>    管道读端没有全部关闭：<br>        管道已满，write阻塞<br>        管道没有满，write将数据写入，并返回实际写入的字节数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    设置管道非阻塞</span></span><br><span class="line"><span class="comment">    int flags = fcntl(fd[0], F_GETFL);  // 获取原来的flag</span></span><br><span class="line"><span class="comment">    flags |= O_NONBLOCK;            // 修改flag的值</span></span><br><span class="line"><span class="comment">    fcntl(fd[0], F_SETFL, flags);   // 设置新的flag</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在fork之前创建管道</span></span><br><span class="line">    <span class="type">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> ret = pipe(pipefd);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am parent process, pid : %d\n&quot;</span>, getpid());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭写端</span></span><br><span class="line">        close(pipefd[<span class="number">1</span>]);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从管道的读取端读取数据</span></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> flags = fcntl(pipefd[<span class="number">0</span>], F_GETFL);  <span class="comment">// 获取原来的flag</span></span><br><span class="line">        flags |= O_NONBLOCK;            <span class="comment">// 修改flag的值</span></span><br><span class="line">        fcntl(pipefd[<span class="number">0</span>], F_SETFL, flags);   <span class="comment">// 设置新的flag</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> len = read(pipefd[<span class="number">0</span>], buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;len : %d/n&quot;</span>, len);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;parent recv : %s, pid : %d\n&quot;</span>, buf, getpid());</span><br><span class="line">            <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">1024</span>);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am child process, pid : %d\n&quot;</span>, getpid());</span><br><span class="line">        <span class="comment">// 关闭读端</span></span><br><span class="line">        close(pipefd[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 向管道中写入数据</span></span><br><span class="line">            <span class="type">char</span> * str = <span class="string">&quot;hello,i am child&quot;</span>;</span><br><span class="line">            write(pipefd[<span class="number">1</span>], str, <span class="built_in">strlen</span>(str));</span><br><span class="line">            sleep(<span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="8-5-有名管道"><a href="#8-5-有名管道" class="headerlink" title="8.5 有名管道"></a>8.5 有名管道</h3><ul>
<li><p>匿名管道，<strong>由于没有名字，只能用于亲缘关系的进程间通信</strong>。为了克服这个缺点，提出了有名管道(FIFO)，也叫命名管道、FIFO文件。</p>
</li>
<li><p>有名管道(FIFO)不同于匿名管道之处在于它提供了一个路径名与之关联，以 FIFO的文件形式存在于文件系统中，并且其打开方式与打开一个普通文件是一样的，这样即使与 FIFO 的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过 FIFO 相互通信，因此，通过FIFO 不相关的进程也能交换数据。</p>
</li>
<li><p>一旦打开了 FIFO，就能在它上面使用与操作匿名管道和其他文件的系统调用一样的I&#x2F;0系统调用了(如read()、write()和close())。与管道一样，FIFO 也有一个写入端和读取端，并且从管道中读取数据的顺序与写入的顺序是一样的。FIFO 的名称也由此而来:先入先出。</p>
</li>
<li><p>有名管道(FIFO)和匿名管道(pipe)有一些特点是相同的，不一样的地方在于</p>
</li>
</ul>
<p>​	1. <strong>FIFO 在文件系统中作为一个特殊文件存在，但FIFO 中的内容却存放在内存中。</strong>（即内核的一个缓冲区）</p>
<p>​	2. 当使用 FIFO 的进程退出后，FIFO 文件将继续保存在文件系统中以便以后使用。</p>
<p>​	3. FIFO 有名字，不相关的进程可以通过打开有名管道进行通信。</p>
<h4 id="有名管道的使用"><a href="#有名管道的使用" class="headerlink" title="有名管道的使用"></a><strong>有名管道的使用</strong></h4><ul>
<li>通过命令创建有名管道<br><strong>mkfifo 名字</strong></li>
<li>通过函数创建有名管道<br><strong>#include &lt;sys&#x2F;types.h&gt;</strong><br><strong>#include &lt;sys&#x2F;stat.h&gt;</strong><br>*<em>int mkfifo(const char <em>pathname,mode_tmode);</em></em></li>
<li>一旦使用 mkfifo 创建了一个 FIFO，就可以使用 open 打开它，常见的文件I&#x2F;0 函数都可用于 fifo。如:close、read、write、unlink等</li>
<li>FIFO 严格遵循先进先出(Firstin First out)，对管道及FIFO 的读总是从开始处返回数据，对它们的写则把数据添加到末尾。它们不支持诸如lseek()等文件定位操作。</li>
</ul>
<p>&#x2F;*<br>    <font color='red'>创建fifo文件</font><br>    <font color='red'>1.通过命令： mkfifo 名字</font><br>   <font color='red'> 2.通过函数：int mkfifo(const char *pathname, mode_t mode);</font></p>
   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mkfifo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<p>​	<font color='red'>pathname: 管道名称的路径</font><br>​	<font color='red'>mode: 文件的权限 和 open 的 mode 是一样,是一个八进制的数</font><br>​        <font color='red'>返回值：成功返回0，失败返回-1，并设置错误号</font></p>
<p>*&#x2F;</p>
<h4 id="有名管道注意事项"><a href="#有名管道注意事项" class="headerlink" title="有名管道注意事项"></a><strong>有名管道注意事项</strong></h4><pre><code> 1. 一个为只读而打开的一个管道的进程会阻塞，直到另外一个进程为只写打开管道
 2.  一个为只写而打开的一个管道的进程会阻塞，直到另外一个进程为只读打开管道
</code></pre>
<p><strong>读管道：</strong></p>
<p>​    管道中有数据，read返回实际读到的字节数</p>
<p>​    管道中无数据：</p>
<p>​      管道写端被全部关闭，read返回0，（相当于读到文件末尾）</p>
<p>​      写端没有全部被关闭，read阻塞等待</p>
<p><font color='blue'>  <strong>写管道：</strong></font></p>
<p>​    管道读端被全部关闭，进行异常终止（收到一个SIGPIPE信号）</p>
<p>​    管道读端没有全部关闭：</p>
<p>​      管道已经满了，write会阻塞</p>
<p>​      管道没有满，write将数据写入，并返回实际写入的字节数。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240509104400591.png" alt="image-20240509104400591"></p>
<h5 id="模拟发送对话"><a href="#模拟发送对话" class="headerlink" title="模拟发送对话"></a>模拟发送对话</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//chatA</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"> <span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//判断有名管道是否存在</span></span><br><span class="line">    <span class="type">int</span> ret = access(<span class="string">&quot;fifo1&quot;</span>, F_OK);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;管道不存在，创建有名管道：\n&quot;</span>);</span><br><span class="line">        ret = mkfifo(<span class="string">&quot;fifo1&quot;</span>, <span class="number">0664</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;mkfifo&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = access(<span class="string">&quot;fifo2&quot;</span>, F_OK);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;管道不存在，创建有名管道：\n&quot;</span>);</span><br><span class="line">        ret = mkfifo(<span class="string">&quot;fifo2&quot;</span>, <span class="number">0664</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;mkfifo&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2. 以只写的方式打开管道1</span></span><br><span class="line">    <span class="type">int</span> fdw = open(<span class="string">&quot;fifo1&quot;</span>, O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span>(fdw == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打开管道fifo1成功, 等待写入...\n&quot;</span>);</span><br><span class="line">    <span class="comment">//3. 以只读的方式打开管道2</span></span><br><span class="line">    <span class="type">int</span> fdr = open(<span class="string">&quot;fifo2&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(fdr == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打开管道fifo2成功, 等待读取...\n&quot;</span>);</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line">    <span class="comment">//4.循环的写读数据</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">128</span>);</span><br><span class="line">        <span class="comment">//获取标准的写入数据,标准输入是stdin</span></span><br><span class="line">        fgets(buf, <span class="number">128</span>, <span class="built_in">stdin</span>);</span><br><span class="line">        <span class="comment">//写数据</span></span><br><span class="line">        ret = write(fdw, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//5.读管道数据</span></span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">128</span>);</span><br><span class="line">        ret = read(fdr, buf, <span class="number">128</span>);</span><br><span class="line">         <span class="keyword">if</span>(ret &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;buf: %s\n&quot;</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//6 关闭文件描述符</span></span><br><span class="line">    close(fdr);</span><br><span class="line">    close(fdw);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//chatB</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"> <span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//判断有名管道是否存在</span></span><br><span class="line">    <span class="type">int</span> ret = access(<span class="string">&quot;fifo1&quot;</span>, F_OK);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;管道不存在，创建有名管道：\n&quot;</span>);</span><br><span class="line">        ret = mkfifo(<span class="string">&quot;fifo1&quot;</span>, <span class="number">0664</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;mkfifo&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = access(<span class="string">&quot;fifo2&quot;</span>, F_OK);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;管道不存在，创建有名管道：\n&quot;</span>);</span><br><span class="line">        ret = mkfifo(<span class="string">&quot;fifo2&quot;</span>, <span class="number">0664</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;mkfifo&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2. 以只读的方式打开管道1</span></span><br><span class="line">    <span class="type">int</span> fdr = open(<span class="string">&quot;fifo1&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(fdr == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打开管道fifo1成功, 等待读取...\n&quot;</span>);</span><br><span class="line">    <span class="comment">//3. 以只写的方式打开管道2</span></span><br><span class="line">    <span class="type">int</span> fdw = open(<span class="string">&quot;fifo2&quot;</span>, O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span>(fdw == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打开管道fifo2成功, 等待写入...\n&quot;</span>);</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line">    <span class="comment">//4.循环的写读数据</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//5.读管道数据</span></span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">128</span>);</span><br><span class="line">        ret = read(fdr, buf, <span class="number">128</span>);</span><br><span class="line">         <span class="keyword">if</span>(ret &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;buf: %s\n&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">128</span>);</span><br><span class="line">        <span class="comment">//获取标准的写入数据,标准输入是stdin</span></span><br><span class="line">        fgets(buf, <span class="number">128</span>, <span class="built_in">stdin</span>);</span><br><span class="line">        <span class="comment">//写数据</span></span><br><span class="line">        ret = write(fdw, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//6 关闭文件描述符</span></span><br><span class="line">    close(fdr);</span><br><span class="line">    close(fdw);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<h3 id="8-6-内存映射"><a href="#8-6-内存映射" class="headerlink" title="8.6 内存映射"></a>8.6 内存映射</h3><p><img src="https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240509132841501.png" alt="image-20240509132841501"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//内存映射相关的系统调用</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *addr, size tlength, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span> *addr,<span class="type">size_t</span> length)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*mmap-parent-child-ipc</span></span><br><span class="line"><span class="comment">    #include &lt;sys/mman.h&gt;</span></span><br><span class="line"><span class="comment">    void *mmap(void *addr, size_t length, int prot, int flags,int fd, off_t offset);</span></span><br><span class="line"><span class="comment">        - 功能：将一个文件或者设备的数据映射到内存中</span></span><br><span class="line"><span class="comment">        - 参数：</span></span><br><span class="line"><span class="comment">            - void *addr: 要映射的内存的首地址，未知为NULL, 由内核指定</span></span><br><span class="line"><span class="comment">            - length : 要映射的数据的长度，这个值不能为0。建议使用文件的长度。</span></span><br><span class="line"><span class="comment">                    获取文件的长度：stat lseek</span></span><br><span class="line"><span class="comment">            - prot : 对申请的内存映射区的操作权限</span></span><br><span class="line"><span class="comment">                -PROT_EXEC ：可执行的权限</span></span><br><span class="line"><span class="comment">                -PROT_READ ：读权限</span></span><br><span class="line"><span class="comment">                -PROT_WRITE ：写权限</span></span><br><span class="line"><span class="comment">                -PROT_NONE ：没有权限</span></span><br><span class="line"><span class="comment">                要操作映射内存，必须要有读的权限。</span></span><br><span class="line"><span class="comment">                PROT_READ、PROT_READ|PROT_WRITE</span></span><br><span class="line"><span class="comment">            - flags :</span></span><br><span class="line"><span class="comment">                - MAP_SHARED : 映射区的数据会自动和磁盘文件进行同步，进程间通信，必须要设置这个选项</span></span><br><span class="line"><span class="comment">                - MAP_PRIVATE ：不同步，内存映射区的数据改变了，对原来的文件不会修改，会重新创建一个新的文件。（copy on write）</span></span><br><span class="line"><span class="comment">            - fd: 需要映射的那个文件的文件描述符</span></span><br><span class="line"><span class="comment">                - 通过open得到，open的是一个磁盘文件</span></span><br><span class="line"><span class="comment">                - 注意：文件的大小不能为0，open指定的权限不能和prot参数有冲突。即prot的权限要小于open的权限</span></span><br><span class="line"><span class="comment">                    prot: PROT_READ                open:只读/读写 </span></span><br><span class="line"><span class="comment">                    prot: PROT_READ | PROT_WRITE   open:读写</span></span><br><span class="line"><span class="comment">            - offset：偏移量，一般不用。必须指定的是4k的整数倍，0表示不便宜。</span></span><br><span class="line"><span class="comment">        - 返回值：返回创建的内存的首地址</span></span><br><span class="line"><span class="comment">            失败返回MAP_FAILED，(void *) -1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    int munmap(void *addr, size_t length);</span></span><br><span class="line"><span class="comment">        - 功能：释放内存映射</span></span><br><span class="line"><span class="comment">        - 参数：</span></span><br><span class="line"><span class="comment">            - addr : 要释放的内存的首地址</span></span><br><span class="line"><span class="comment">            - length : 要释放的内存的大小，要和mmap函数中的length参数的值一样。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    使用内存映射实现进程间通信：</span></span><br><span class="line"><span class="comment">    1.有关系的进程（父子进程）</span></span><br><span class="line"><span class="comment">        - 还没有子进程的时候</span></span><br><span class="line"><span class="comment">            - 通过唯一的父进程，先创建内存映射区</span></span><br><span class="line"><span class="comment">        - 有了内存映射区以后，创建子进程</span></span><br><span class="line"><span class="comment">        - 父子进程共享创建的内存映射区</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    2.没有关系的进程间通信</span></span><br><span class="line"><span class="comment">        - 准备一个大小不是0的磁盘文件</span></span><br><span class="line"><span class="comment">        - 进程1 通过磁盘文件创建内存映射区</span></span><br><span class="line"><span class="comment">            - 得到一个操作这块内存的指针</span></span><br><span class="line"><span class="comment">        - 进程2 通过磁盘文件创建内存映射区 （磁盘文件是相同的） </span></span><br><span class="line"><span class="comment">            - 得到一个操作这块内存的指针</span></span><br><span class="line"><span class="comment">        - 使用内存映射区通信</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    注意：内存映射区通信，是非阻塞。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 作业:使用内存映射实现没有关系的进程间的通信。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.打开一个文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;test.txt&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="type">int</span> size = lseek(fd, <span class="number">0</span>, SEEK_END);  <span class="comment">// 获取文件的大小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.创建内存映射区</span></span><br><span class="line">    <span class="type">void</span> *ptr = mmap(<span class="literal">NULL</span>, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ptr == MAP_FAILED) &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.创建子进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">64</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(buf, (<span class="type">char</span> *)ptr);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;read data : %s\n&quot;</span>, buf);</span><br><span class="line">       </span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        <span class="built_in">strcpy</span>((<span class="type">char</span> *)ptr, <span class="string">&quot;nihao a, son!!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭内存映射区</span></span><br><span class="line">    munmap(ptr, size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="内存映射的注意事项"><a href="#内存映射的注意事项" class="headerlink" title="内存映射的注意事项"></a>内存映射的注意事项</h4><p><strong>1.如果对mmap的返回值(ptr)做++操作(ptr++), munmap是否能够成功?</strong></p>
<p>​	void * ptr &#x3D; mmap(…);<br>​	ptr++;  可以对其进行++操作<br>​	munmap(ptr, len);   &#x2F;&#x2F; 错误,要保存地址</p>
<p><strong>2.如果open时O_RDONLY, mmap时prot参数指定PROT_READ | PROT_WRITE会怎样?</strong></p>
<p>​	错误，返回MAP_FAILED<br>​	open()函数中的权限建议和prot参数的权限保持一致。</p>
<p><strong>3.如果文件偏移量为1000会怎样?</strong></p>
<p>​	偏移量必须是4K的整数倍，返回MAP_FAILED</p>
<p><strong>4.mmap什么情况下会调用失败?</strong></p>
<pre><code>- 第二个参数：length = 0
    - 第三个参数：prot
    - 只指定了写权限
    - prot PROT_READ | PROT_WRITE
      第5个参数fd 通过open函数时指定的 O_RDONLY / O_WRONLY
</code></pre>
<p><strong>5.可以open的时候O_CREAT一个新文件来创建映射区吗?</strong><br>    - 可以的，但是创建的文件的大小如果为0的话，肯定不行<br>        - 可以对新的文件进行扩展<br>          - lseek()<br>          - truncate()</p>
<p><strong>6.mmap后关闭文件描述符，对mmap映射有没有影响？</strong><br>    int fd &#x3D; open(“XXX”);<br>    mmap(,,,,fd,0);<br>    close(fd);<br>    映射区还存在，创建映射区的fd被关闭，没有任何影响。</p>
<p><strong>7.对ptr越界操作会怎样？</strong><br>    void * ptr &#x3D; mmap(NULL, 100,,,,,);<br>    4K<br>    越界操作操作的是非法的内存 -&gt; 段错误</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用内存映射实现文件拷贝的功能</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    思路：</span></span><br><span class="line"><span class="comment">        1.对原始的文件进行内存映射</span></span><br><span class="line"><span class="comment">        2.创建一个新文件（拓展该文件）</span></span><br><span class="line"><span class="comment">        3.把新文件的数据映射到内存中</span></span><br><span class="line"><span class="comment">        4.通过内存拷贝将第一个文件的内存数据拷贝到新的文件内存中</span></span><br><span class="line"><span class="comment">        5.释放资源</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.对原始的文件进行内存映射</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;english.txt&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取原始文件的大小</span></span><br><span class="line">    <span class="type">int</span> len = lseek(fd, <span class="number">0</span>, SEEK_END);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.创建一个新文件（拓展该文件）</span></span><br><span class="line">    <span class="type">int</span> fd1 = open(<span class="string">&quot;cpy.txt&quot;</span>, O_RDWR | O_CREAT, <span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd1 == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对新创建的文件进行拓展</span></span><br><span class="line">    truncate(<span class="string">&quot;cpy.txt&quot;</span>, len);</span><br><span class="line">    write(fd1, <span class="string">&quot; &quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.分别做内存映射</span></span><br><span class="line">    <span class="type">void</span> * ptr = mmap(<span class="literal">NULL</span>, len, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="type">void</span> * ptr1 = mmap(<span class="literal">NULL</span>, len, PROT_READ | PROT_WRITE, MAP_SHARED, fd1, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ptr == MAP_FAILED) &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ptr1 == MAP_FAILED) &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内存拷贝</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr1, ptr, len);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    munmap(ptr1, len);</span><br><span class="line">    munmap(ptr, len);</span><br><span class="line"></span><br><span class="line">    close(fd1);</span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    匿名映射：不需要文件实体进程一个内存映射</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/mman-linux.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建匿名内存映射区</span></span><br><span class="line">    <span class="type">int</span> len = <span class="number">4096</span>;</span><br><span class="line">    <span class="type">void</span> * ptr = mmap(<span class="literal">NULL</span>, len, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ptr == MAP_FAILED) &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父子进程间通信</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="built_in">strcpy</span>((<span class="type">char</span> *) ptr, <span class="string">&quot;hello, world&quot;</span>);</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, (<span class="type">char</span> *)ptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放内存映射区</span></span><br><span class="line">    <span class="type">int</span> ret = munmap(ptr, len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;munmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-信号概述"><a href="#9-信号概述" class="headerlink" title="9.信号概述"></a>9.信号概述</h2><h3 id="9-1信号的概念"><a href="#9-1信号的概念" class="headerlink" title="9.1信号的概念"></a>9.1信号的概念</h3><ul>
<li><p>信号是 inux 进程间通信的最古老的方式之一，是事件发生时对进程的通知机制，有时也称之为<strong>软件中断</strong>，它是在软件层次上对中断机制的一种模拟，是一种<strong>异步通信</strong>的方式。信号可以导致一个正在运行的进程被另一个正在运行的异步进程中断，转而处理某一个突发事件</p>
</li>
<li><p>发往进程的诸多信号，通常都是源于内核。引发内核为进程产生信号的各类事件如下:</p>
<ul>
<li>对于前台进程，用户可以通过输入特殊的终端字符来给它发送信号。比如输入ctr1+C通常会给进程发送一个中断信号。</li>
<li>硬件发生异常，即硬件检测到一个错误条件并通知内核，随即再由内核发送相应信号给相关进程。比如执行一条异常的机器语言指令，诸如被0除，或者引用了无法访问的内存区域。</li>
<li>系统状态变化，比如 alarm定时器到期将引起SIGALRM 信号，进程执行的CPU时间超限，或者该进程的某个子进程退出。</li>
<li>运行 kill 命令或调用 kill 函数。</li>
</ul>
</li>
<li><p>使用信号的两个主要目的是</p>
<ul>
<li>让进程知道已经发生了一个特定的事情。</li>
<li>强迫进程执行它自己代码中的信号处理程序。</li>
</ul>
</li>
<li><p>信号的特点</p>
<ul>
<li>简单</li>
<li>不能携带大量信息</li>
<li>满足某个特定条件才发送</li>
<li>优先级比较高</li>
<li>查看系统定义的信号列表:<code>kill -l</code></li>
<li>前 31 个信号为常规信号，其余为实时信号</li>
</ul>
</li>
<li><p><strong>Linux信号一览表</strong></p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240510213256080.png" alt="image-20240510213256080"></p>
<p> <img src="https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240510215323534.png" alt="image-20240510215323534"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240510215343866.png" alt="image-20240510215343866"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240510215530329.png" alt="image-20240510215530329"></p>
<h4 id="信号的5种默认处理动作"><a href="#信号的5种默认处理动作" class="headerlink" title="信号的5种默认处理动作"></a>信号的5种默认处理动作</h4><p>查看信号的详细信息: <code>man 7 signal</code></p>
<p>信号的 5 中默认处理动作<br>Termk              终止进程<br>Ign                    当前进程忽略掉这个信号<br>Core                 终止进程，并生成一个Core文件<br>Stop                 暂停当前进程<br>Cont                继续执行当前被暂停的进程</p>
<p>信号的几种状态:产生、未决、递达<br><strong>SIGKILL</strong>和 <strong>SIGSTOP</strong> 信号不能被捕捉、阻塞或者忽略，只能执行默认动作</p>
<p><code>进入gdb查看错误：core-file core</code></p>
<h3 id="9-2kill、raise、abort函数"><a href="#9-2kill、raise、abort函数" class="headerlink" title="9.2kill、raise、abort函数"></a>9.2kill、raise、abort函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment">    #include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;signal.h&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    int kill(pid_t pid, int sig);</span></span><br><span class="line"><span class="comment">        - 功能：给任何的进程或者进程组pid, 发送任何的信号 sig</span></span><br><span class="line"><span class="comment">        - 参数：</span></span><br><span class="line"><span class="comment">            - pid ：</span></span><br><span class="line"><span class="comment">                &gt; 0 : 将信号发送给指定的进程</span></span><br><span class="line"><span class="comment">                = 0 : 将信号发送给当前的进程组</span></span><br><span class="line"><span class="comment">                = -1 : 将信号发送给每一个有权限接收这个信号的进程</span></span><br><span class="line"><span class="comment">                &lt; -1 : 这个pid=某个进程组的ID取反 （-12345）</span></span><br><span class="line"><span class="comment">            - sig : 需要发送的信号的编号或者是宏值，0表示不发送任何信号</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        kill(getppid(), 9);</span></span><br><span class="line"><span class="comment">        kill(getpid(), 9);</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">    int raise(int sig);</span></span><br><span class="line"><span class="comment">        - 功能：给当前进程发送信号</span></span><br><span class="line"><span class="comment">        - 参数：</span></span><br><span class="line"><span class="comment">            - sig : 要发送的信号</span></span><br><span class="line"><span class="comment">        - 返回值：</span></span><br><span class="line"><span class="comment">            - 成功 0</span></span><br><span class="line"><span class="comment">            - 失败 非0</span></span><br><span class="line"><span class="comment">        kill(getpid(), sig);   </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    void abort(void);</span></span><br><span class="line"><span class="comment">        - 功能： 发送SIGABRT信号给当前的进程，杀死当前进程</span></span><br><span class="line"><span class="comment">        kill(getpid(), SIGABRT);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="9-3alarm-函数"><a href="#9-3alarm-函数" class="headerlink" title="9.3alarm 函数"></a>9.3alarm 函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">    unsigned int alarm(unsigned int seconds);</span></span><br><span class="line"><span class="comment">        - 功能：设置定时器（闹钟）。函数调用，开始倒计时，当倒计时为0的时候，</span></span><br><span class="line"><span class="comment">                函数会给当前的进程发送一个信号：SIGALARM</span></span><br><span class="line"><span class="comment">        - 参数：</span></span><br><span class="line"><span class="comment">            seconds: 倒计时的时长，单位：秒。如果参数为0，定时器无效（不进行倒计时，不发信号）。</span></span><br><span class="line"><span class="comment">                    取消一个定时器，通过alarm(0)。</span></span><br><span class="line"><span class="comment">        - 返回值：</span></span><br><span class="line"><span class="comment">            - 之前没有定时器，返回0</span></span><br><span class="line"><span class="comment">            - 之前有定时器，返回之前的定时器剩余的时间</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    - SIGALARM ：默认终止当前的进程，每一个进程都有且只有唯一的一个定时器。</span></span><br><span class="line"><span class="comment">        alarm(10);  -&gt; 返回0</span></span><br><span class="line"><span class="comment">        过了1秒</span></span><br><span class="line"><span class="comment">        alarm(5);   -&gt; 返回9</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    alarm(100) -&gt; 该函数是不阻塞的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> seconds = alarm(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;seconds = %d\n&quot;</span>, seconds);  <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    seconds = alarm(<span class="number">2</span>);    <span class="comment">// 不阻塞</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;seconds = %d\n&quot;</span>, seconds);  <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>实际的时间</strong> &#x3D; 内核时间 + 用户时间 + 消耗的时间</p>
<p>  进行文件IO操作的时候比较浪费时间</p>
<p>  定时器,与进程的状态无关（自然定时法）。无论进程处于什么状态，alarm都会计时。</p>
<h3 id="9-4signal信号捕捉函数"><a href="#9-4signal信号捕捉函数" class="headerlink" title="9.4signal信号捕捉函数"></a>9.4signal信号捕捉函数</h3><pre><code>#include &lt;signal.h&gt;
typedef void (*sighandler_t)(int);
sighandler_t  signal(int signum, sighandler_t handler);
- 功能：设置某个信号的捕捉行为：
            - 参数- signum: 要捕捉的信号
        - handler: 捕捉到信号要如何处理
            - SIG_IGN ： 忽略信号
            - SIG_DFL ： 使用信号默认的行为
            - 回调函数 :  这个函数是内核调用，程序员只负责写，捕捉到信号后如何去处理信号。
            回调函数：
                - 需要程序员实现，提前准备好的，函数的类型根据实际需求，看函数指针的定义
                - 不是程序员调用，而是当信号产生，由内核调用
                - 函数指针是实现回调的手段，函数实现之后，将函数名放到函数指针的位置就可以了。
        
                - 返回值：
        成功，返回上一次注册的信号处理函数的地址。第一次调用返回NULL
            失败，返回SIG_ERR，设置错误号
</code></pre>
<p>​    <strong>SIGKILL SIGSTOP不能被捕捉，不能被忽略。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">myalarm</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;捕捉到了信号的编号是：%d\n&quot;</span>, num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;xxxxxxx\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 过3秒以后，每隔2秒钟定时一次</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册信号捕捉</span></span><br><span class="line">    <span class="comment">// signal(SIGALRM, SIG_IGN);</span></span><br><span class="line">    <span class="comment">// signal(SIGALRM, SIG_DFL);</span></span><br><span class="line">    <span class="comment">// void (*sighandler_t)(int); 函数指针，int类型的参数表示捕捉到的信号的值。</span></span><br><span class="line">    signal(SIGALRM, myalarm);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">new_value</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置间隔的时间</span></span><br><span class="line">    new_value.it_interval.tv_sec = <span class="number">2</span>;</span><br><span class="line">    new_value.it_interval.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置延迟的时间,3秒之后开始第一次定时</span></span><br><span class="line">    new_value.it_value.tv_sec = <span class="number">3</span>;</span><br><span class="line">    new_value.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = setitimer(ITIMER_REAL, &amp;new_value, <span class="literal">NULL</span>); <span class="comment">// 非阻塞的</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;定时器开始了...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;setitimer&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-5信号集及其相关函数"><a href="#9-5信号集及其相关函数" class="headerlink" title="9.5信号集及其相关函数"></a>9.5信号集及其相关函数</h3><h4 id="信号集"><a href="#信号集" class="headerlink" title="信号集"></a>信号集</h4><ul>
<li>许多信号相关的系统调用都需要能表示一组不同的信号，多个信号可使用一个称之为信号集的数据结构来表示，其系统数据类型为 <strong>sigset_t。</strong></li>
<li>在 PCB 中有两个非常重要的信号集。一个称之为“阻塞信号集”，另一个称之为“未决信号集”。这两个信号集都是内核使用位图机制来实现的。但操作系统不允许我们直接对这两个信号集进行位操作。而需自定义另外一个集合，借助信号集操作函数来对 PCB 中的这两个信号集进行修改。</li>
<li>信号的“未决”是一种状态，指的是从信号的产生到信号被处理前的这一段时间</li>
<li>信号的“阻塞”是一个开关动作，指的是阻止信号被处理，但不是阻止信号产生</li>
<li>信号的阻塞就是让系统暂时保留信号留待以后发送。由于另外有办法让系统忽略信号所以一般情况下信号的阻塞只是暂时的，<strong>只是为了防止信号打断敏感的操作。</strong></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240513211828372.png" alt="image-20240513211828372"></p>
<p>1.用户通过键盘  Ctrl + C, 产生2号信号SIGINT (信号被创建)</p>
<p>2.信号产生但是没有被处理 （未决）<br>    - 在内核中将所有的没有被处理的信号存储在一个集合中 （未决信号集）<br>        - SIGINT信号状态被存储在第二个标志位上<br>        - 这个标志位的值为0， 说明信号不是未决状态<br>        - 这个标志位的值为1， 说明信号处于未决状态</p>
<p>3.这个未决状态的信号，需要被处理，处理之前需要和另一个信号集（阻塞信号集），进行比较</p>
<ul>
<li><strong>阻塞信号集默认不阻塞任何的信号</strong></li>
<li>如果想要阻塞某些信号需要用户调用系统的API</li>
</ul>
<p>4.在处理的时候和阻塞信号集中的标志位进行查询，看是不是对该信号设置阻塞了</p>
<ul>
<li><p>如果没有阻塞，这个信号就被处理</p>
</li>
<li><p>如果阻塞了，这个信号就继续处于未决状态，直到阻塞解除，这个信号就被处理</p>
</li>
</ul>
<p><font color='red'><strong>以下信号集相关的函数都是对自定义的信号集进行操作。</strong></font></p>
<p>   <code> int sigemptyset(sigset_t  * set);</code></p>
<ul>
<li><font color='blue'>功能：清空信号集中的数据,将信号集中的所有的标志位置为0：</font><br>  - set,传出参数，需要操作的信号集<br>  - 返回值：成功返回0， 失败返回-1</li>
</ul>
<p>   <code> int sigfillset(sigset_t *set);</code><br>        - <font color='blue'>功能：将信号集中的所有的标志位置为1</font><br>                - 参数<br>        * set,传出参数，需要操作的信号集<br>          - 返回值：成功返回0， 失败返回-1</p>
<p>  <code>  int sigaddset(sigset_t *set, int signum);</code><br>        - <font color='blue'>功能：设置信号集中的某一个信号对应的标志位为1，表示阻塞这个信号：</font><br>                - 参数- set：传出参数，需要操作的信号集<br>            - signum：需要设置阻塞的那个信号<br>                    - 返回值：成功返回0， 失败返回-1</p>
<p>  <code>  int sigdelset(sigset_t *set, int signum);</code><br>        - <font color='blue'>功能：设置信号集中的某一个信号对应的标志位为0，表示不阻塞这个信号：</font><br>                - 参数- set：传出参数，需要操作的信号集<br>            - signum：需要设置不阻塞的那个信号<br>                    - 返回值：成功返回0， 失败返回-1</p>
<p>   <code> int sigismember(const sigset_t *set, int signum);</code><br>        - <font color='blue'>功能：判断某个信号是否阻塞：</font><br>                - 参数- set：需要操作的信号集<br>            - signum：需要判断的那个信号<br>                    - 返回值：<br>            1 ： signum被阻塞<br>                0 ： signum不阻塞,不在信号集中<br>                -1 ： 失败</p>
<h4 id="sigprocmask函数"><a href="#sigprocmask函数" class="headerlink" title="sigprocmask函数"></a>sigprocmask函数</h4><p><img src="https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240513222510830.png" alt="image-20240513222510830"></p>
<p> <code>int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);</code><br>        - <font color='red'>功能：将自定义信号集中的数据设置到内核中（设置阻塞，解除阻塞，替换）：</font><br>                - 参数- <strong>how : 如何对内核阻塞信号集进行处理</strong><br>                <font color='blue'>SIG_BLOCK: 将用户设置的阻塞信号集添加到内核中，内核中原来的数据不变</font><br>                    假设内核中默认的阻塞信号集是mask， mask | set<br>                <font color='blue'>SIG_UNBLOCK: 根据用户设置的数据，对内核中的数据进行解除阻塞</font><br>                    mask &amp;&#x3D; ~set<br>                <font color='blue'>SIG_SETMASK:覆盖内核中原来的值</font><br>                     - set ：已经初始化好的用户自定义的信号集<br>                        - oldset : 保存设置之前的内核中的阻塞信号集的状态，可以是 NULL<br>                - 返回值：<br>                   成功：0<br>                           失败：-1<br>                            设置错误号：EFAULT、EINVAL </p>
<p>​       </p>
<p>  <code>  int sigpending(sigset_t *set);</code></p>
<ul>
<li><font color='red'>功能：获取内核中的未决信号集</font>：<ul>
<li>set,传出参数，保存的是内核中的未决信号集中的信息。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编写一个程序，把所有的常规信号（1-31）的未决状态打印到屏幕</span></span><br><span class="line"><span class="comment">// 设置某些信号是阻塞的，通过键盘产生这些信号</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置2、3号信号阻塞</span></span><br><span class="line">    <span class="type">sigset_t</span> <span class="built_in">set</span>;</span><br><span class="line">    sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">    <span class="comment">// 将2号和3号信号添加到信号集中</span></span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>, SIGINT);</span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>, SIGQUIT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改内核中的阻塞信号集</span></span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;<span class="built_in">set</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        num++;</span><br><span class="line">        <span class="comment">// 获取当前的未决信号集的数据</span></span><br><span class="line">        <span class="type">sigset_t</span> pendingset;</span><br><span class="line">        sigemptyset(&amp;pendingset);</span><br><span class="line">        sigpending(&amp;pendingset);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历前32位</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">31</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(sigismember(&amp;pendingset, i) == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sigismember(&amp;pendingset, i) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                perror(<span class="string">&quot;sigismember&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="comment">// 解除阻塞</span></span><br><span class="line">            sigprocmask(SIG_UNBLOCK, &amp;<span class="built_in">set</span>, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后台运行—— <code>./可执行文件名 &amp;</code></p>
<p><code>fg</code>指令切换到前台</p>
<h4 id="sigaction"><a href="#sigaction" class="headerlink" title="sigaction"></a>sigaction</h4><p> <code>#include &lt;signal.h&gt;</code><br>   <code> int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);</code></p>
<pre><code>    - 功能：检查或者改变信号的处理。信号捕捉：
            - 参数- signum : 需要捕捉的信号的编号或者宏值（信号的名称）
        - act ：捕捉到信号之后的处理动作
        - oldact : 上一次对信号捕捉相关的设置，一般不使用，传递NULL
                - 返回值：
        成功 0
            失败 -1
</code></pre>
<p>​     struct sigaction {</p>
<p>​        &#x2F;&#x2F; 函数指针，指向的函数就是信号捕捉到之后的处理函数<br>​       <code> void     (*sa_handler)(int);</code>1️⃣</p>
<p>​        &#x2F;&#x2F; 不常用<br>​      <code>  void     (*sa_sigaction)(int, siginfo_t *, void *);</code>2️⃣</p>
<p>​        &#x2F;&#x2F; 临时阻塞信号集，在信号捕捉函数执行过程中，临时阻塞某些信号。<br>​      <code>   sigset_t   sa_mask;</code></p>
<p>​        &#x2F;&#x2F; 使用哪一个信号处理对捕捉到的信号进行处理1️⃣或者2️⃣<br>​        &#x2F;&#x2F; 这个值可以是0，表示使用<code>sa_handler</code>1️⃣,也可以是<code>SA_SIGINFO</code>表示使用<code>sa_sigaction</code>2️⃣<br>​      <code>  int        sa_flags;</code><br>​        &#x2F;&#x2F; 被废弃掉了<br>​       <code> void     (*sa_restorer)(void);</code><br>​    };</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">myalarm</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;捕捉到了信号的编号是：%d\n&quot;</span>, num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;xxxxxxx\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 过3秒以后，每隔2秒钟定时一次</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    act.sa_flags = <span class="number">0</span>;</span><br><span class="line">    act.sa_handler = myalarm;</span><br><span class="line">    sigemptyset(&amp;act.sa_mask);  <span class="comment">// 清空临时阻塞信号集</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 注册信号捕捉</span></span><br><span class="line">    sigaction(SIGALRM, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">new_value</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置间隔的时间</span></span><br><span class="line">    new_value.it_interval.tv_sec = <span class="number">2</span>;</span><br><span class="line">    new_value.it_interval.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置延迟的时间,3秒之后开始第一次定时</span></span><br><span class="line">    new_value.it_value.tv_sec = <span class="number">3</span>;</span><br><span class="line">    new_value.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = setitimer(ITIMER_REAL, &amp;new_value, <span class="literal">NULL</span>); <span class="comment">// 非阻塞的</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;定时器开始了...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;setitimer&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getchar();</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240515132939739.png" alt="image-20240515132939739"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Linff214/picodemo/img/image-20240515134207766.png" alt="image-20240515134207766"></p>
<h4 id="SIGCHLD"><a href="#SIGCHLD" class="headerlink" title="SIGCHLD"></a>SIGCHLD</h4><p><strong><font color='purple'>SIGCHLD信号产生的3个条件：</font></strong></p>
<p>​    1.子进程结束</p>
<p>​    2.子进程暂停了</p>
<p>​    3.子进程继续运行</p>
<p>​    都会给父进程发送该信号，父进程默认忽略该信号。</p>
<p><strong><font color='red'>使用SIGCHLD信号解决僵尸进程的问题。</font></strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">myFun</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;捕捉到的信号 ：%d\n&quot;</span>, num);</span><br><span class="line">    <span class="comment">// 回收子进程PCB的资源</span></span><br><span class="line">    <span class="comment">// while(1) &#123;</span></span><br><span class="line">    <span class="comment">//     wait(NULL); </span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">       <span class="type">int</span> ret = waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, WNOHANG);</span><br><span class="line">       <span class="keyword">if</span>(ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">&quot;child die , pid = %d\n&quot;</span>, ret);</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">// 说明还有子进程活着</span></span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">           <span class="comment">// 没有子进程</span></span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提前设置好阻塞信号集，阻塞SIGCHLD，因为有可能子进程很快结束，父进程还没有注册完信号捕捉</span></span><br><span class="line">    <span class="type">sigset_t</span> <span class="built_in">set</span>;</span><br><span class="line">    sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>, SIGCHLD);</span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;<span class="built_in">set</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一些子进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 捕捉子进程死亡时发送的SIGCHLD信号</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">        act.sa_flags = <span class="number">0</span>;</span><br><span class="line">        act.sa_handler = myFun;</span><br><span class="line">        sigemptyset(&amp;act.sa_mask);</span><br><span class="line">        sigaction(SIGCHLD, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注册完信号捕捉以后，解除阻塞</span></span><br><span class="line">        sigprocmask(SIG_UNBLOCK, &amp;<span class="built_in">set</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;parent process pid : %d\n&quot;</span>, getpid());</span><br><span class="line">            sleep(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>( pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child process pid : %d\n&quot;</span>, getpid());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://Linff214.github.io">Linff214</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://linff214.github.io/2024/04/21/%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8/">https://linff214.github.io/2024/04/21/%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://Linff214.github.io" target="_blank">小林小林爱编程</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Linux/">Linux</a></div><div class="post_share"><div class="social-share" data-image="/img/%E7%8C%AB%E7%8C%AB2.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/04/24/%E7%AE%97%E6%B3%95%E9%A2%98%E6%80%BB%E7%BB%93/" title="算法题总结"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">算法题总结</div></div></a></div><div class="next-post pull-right"><a href="/2024/04/21/transformation/" title="基于投影变换的锥束层析成像重建方法"><img class="cover" src="/img/%E7%8C%AB%E7%8C%AB3.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">基于投影变换的锥束层析成像重建方法</div></div></a></div></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="lv-container" data-id="city" data-uid="MTAyMC81OTc3Mi8zNjIzNA=="></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/%E5%A4%B4%E5%83%8F.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Linff214</div><div class="author-info__description">纵有疾风来，人生不言弃</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Linff214"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Linff214" target="_blank" title="Github"><i class="fab fa-github" style="color: #hdhfbb;"></i></a><a class="social-icon" href="mailto:xxxxxx@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #000000;"></i></a><a class="social-icon" href="/blog.Linff214.com" target="_blank" title="博客"><i class="fa-solid fa-layer-group"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-lt-font-gt-%E7%9A%84%E6%A0%87%E7%AD%BE%E7%9A%84%E4%BF%AE%E6%94%B9%E6%96%87%E5%AD%97%E5%89%8D%E6%99%AF%E8%89%B2"><span class="toc-number">1.</span> <span class="toc-text">使用 &lt;font&gt; 的标签的修改文字前景色</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Gcc"><span class="toc-number"></span> <span class="toc-text">1. Gcc</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E9%9D%99%E6%80%81%E5%BA%93%E5%88%B6%E4%BD%9C%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="toc-number"></span> <span class="toc-text">2. 静态库制作和使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%88%B6%E4%BD%9C%E5%8A%A8%E6%80%81%E5%BA%93"><span class="toc-number"></span> <span class="toc-text">3. 制作动态库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1export%E6%B7%BB%E5%8A%A0%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%EF%BC%88%E4%B8%B4%E6%97%B6%EF%BC%89"><span class="toc-number"></span> <span class="toc-text">3.1export添加环境变量（临时）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2%E6%B7%BB%E5%8A%A0%E6%8D%A2%E5%8F%98%E9%87%8F%EF%BC%88%E9%95%BF%E6%9C%9F%EF%BC%89"><span class="toc-number"></span> <span class="toc-text">3.2添加换变量（长期）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3%E5%8A%A8%E9%9D%99%E6%80%81%E5%BA%93%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number"></span> <span class="toc-text">3.3动静态库的优缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Makefile"><span class="toc-number"></span> <span class="toc-text">4. Makefile</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E4%BB%80%E4%B9%88%E6%98%AFMakefile"><span class="toc-number"></span> <span class="toc-text">4.1 什么是Makefile</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number"></span> <span class="toc-text">4.3 工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F"><span class="toc-number"></span> <span class="toc-text">4.4 自定义变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="toc-number"></span> <span class="toc-text">4.5 模式匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-%E5%87%BD%E6%95%B0"><span class="toc-number"></span> <span class="toc-text">4.6 函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-GBD%E8%B0%83%E8%AF%95"><span class="toc-number"></span> <span class="toc-text">5. GBD调试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E4%BB%80%E4%B9%88%E6%98%AF-GDB"><span class="toc-number"></span> <span class="toc-text">5.1 什么是 GDB</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C"><span class="toc-number"></span> <span class="toc-text">5.2 准备工作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-GDB%E5%91%BD%E4%BB%A4-%E5%90%AF%E5%8A%A8%E3%80%81%E6%8E%A8%E5%87%BA%E3%80%81%E6%9F%A5%E7%9C%8B%E4%BB%A3%E7%A0%81"><span class="toc-number"></span> <span class="toc-text">5.3 GDB命令-启动、推出、查看代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-GBD%E5%91%BD%E4%BB%A4-%E6%96%AD%E7%82%B9%E6%93%8D%E4%BD%9C"><span class="toc-number"></span> <span class="toc-text">5.4 GBD命令-断点操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-GBD%E5%91%BD%E4%BB%A4-%E8%B0%83%E8%AF%95%E5%91%BD%E4%BB%A4"><span class="toc-number"></span> <span class="toc-text">5.5 GBD命令-调试命令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E6%96%87%E4%BB%B6I-x2F-O%EF%BC%88%E9%92%88%E5%AF%B9%E5%86%85%E5%AD%98%E8%80%8C%E8%A8%80%EF%BC%89"><span class="toc-number"></span> <span class="toc-text">6. 文件I&#x2F;O（针对内存而言）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E6%A0%87%E5%87%86C%E5%BA%93IO%E5%87%BD%E6%95%B0"><span class="toc-number"></span> <span class="toc-text">6.1 标准C库IO函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E6%A0%87%E5%87%86C%E5%BA%93IO%E5%92%8CLinux%E7%B3%BB%E7%BB%9F%E5%92%8CIO%E5%85%B3%E7%B3%BB"><span class="toc-number"></span> <span class="toc-text">6.2 标准C库IO和Linux系统和IO关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="toc-number"></span> <span class="toc-text">6.3 虚拟地址空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number"></span> <span class="toc-text">6.4 文件描述符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-open%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6"><span class="toc-number"></span> <span class="toc-text">6.5 open打开文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-open%E5%88%9B%E5%BB%BA%E6%96%B0%E6%96%87%E4%BB%B6"><span class="toc-number"></span> <span class="toc-text">6.6 open创建新文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-Linux%E7%B3%BB%E7%BB%9Fi-x2F-o%E5%87%BD%E6%95%B0"><span class="toc-number"></span> <span class="toc-text">6.5 Linux系统i&#x2F;o函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6lseek%E5%87%BD%E6%95%B0"><span class="toc-number"></span> <span class="toc-text">6.6lseek函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-lstat%E5%87%BD%E6%95%B0%E5%92%8Cstat%E5%87%BD%E6%95%B0"><span class="toc-number"></span> <span class="toc-text">6.6 lstat函数和stat函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-7%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0ls-l%E5%91%BD%E4%BB%A4"><span class="toc-number"></span> <span class="toc-text">6.7模拟实现ls-l命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-8-%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0"><span class="toc-number"></span> <span class="toc-text">6.8 文件属性操作函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-9-%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0"><span class="toc-number"></span> <span class="toc-text">6.9 目录操作函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-10-%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86%E5%87%BD%E6%95%B0"><span class="toc-number"></span> <span class="toc-text">6.10 目录遍历函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-11-dup%E3%80%81dup2%E5%87%BD%E6%95%B0"><span class="toc-number"></span> <span class="toc-text">6.11 dup、dup2函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-12-fcntl%E5%87%BD%E6%95%B0"><span class="toc-number"></span> <span class="toc-text">6.12  fcntl函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E8%BF%9B%E7%A8%8B"><span class="toc-number"></span> <span class="toc-text">7. 进程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1%E8%BF%9B%E7%A8%8B%E6%A6%82%E8%BF%B0"><span class="toc-number"></span> <span class="toc-text">7.1进程概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-1-%E7%A8%8B%E5%BA%8F%E4%B8%8E%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">7.1.1 程序与进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-2-%E5%8D%95%E9%81%93%E3%80%81%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="toc-number">2.</span> <span class="toc-text">7.1.2 单道、多道程序设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-3-%E6%97%B6%E9%97%B4%E7%89%87"><span class="toc-number">3.</span> <span class="toc-text">7.1.3 时间片</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-4-%E5%B9%B6%E8%A1%8C%E5%92%8C%E5%B9%B6%E5%8F%91"><span class="toc-number">4.</span> <span class="toc-text">7.1.4 并行和并发</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-5-%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97PCB-x2F-%E8%BF%9B%E7%A8%8B%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8"><span class="toc-number">5.</span> <span class="toc-text">7.1.5 进程控制块PCB&#x2F;进程描述符表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2"><span class="toc-number"></span> <span class="toc-text">7.2 进程状态转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-1-%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">1.</span> <span class="toc-text">7.2.1 进程的状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-2-%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4"><span class="toc-number">2.</span> <span class="toc-text">7.2.2 进程相关命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-3%E8%BF%9B%E7%A8%8B%E5%8F%B7%E5%92%8C%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="toc-number">3.</span> <span class="toc-text">7.2.3进程号和相关函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA"><span class="toc-number"></span> <span class="toc-text">7.3 进程创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-%E7%88%B6%E5%AD%90%E8%BF%9B%E7%A8%8B%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E6%83%85%E5%86%B5"><span class="toc-number"></span> <span class="toc-text">7.4 父子进程虚拟地址空间情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-%E7%88%B6%E5%AD%90%E8%BF%9B%E7%A8%8B%E5%85%B3%E7%B3%BB%E5%8F%8AGBD%E5%A4%9A%E8%BF%9B%E7%A8%8B%E8%B0%83%E8%AF%95"><span class="toc-number"></span> <span class="toc-text">7.5 父子进程关系及GBD多进程调试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-5-1-GBD%E5%A4%9A%E8%BF%9B%E7%A8%8B%E8%B0%83%E8%AF%95"><span class="toc-number">1.</span> <span class="toc-text">7.5.1 GBD多进程调试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-6-exec%E5%87%BD%E6%95%B0%E6%97%8F"><span class="toc-number"></span> <span class="toc-text">7.6 exec函数族</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-6-1exec%E5%87%BD%E6%95%B0%E6%97%8F%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.</span> <span class="toc-text">7.6.1exec函数族介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-6-2-%E5%87%BD%E6%95%B0%E6%97%8F%E5%9B%BE%E8%A7%A3"><span class="toc-number">2.</span> <span class="toc-text">7.6.2 函数族图解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-6-4-exec%E5%87%BD%E6%95%B0%E6%97%8F"><span class="toc-number">3.</span> <span class="toc-text">7.6.4 exec函数族</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-7-%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number"></span> <span class="toc-text">7.7 进程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-7-1%E8%BF%9B%E7%A8%8B%E9%80%80%E5%87%BAexit"><span class="toc-number">1.</span> <span class="toc-text">7.7.1进程退出exit</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-7-2%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">7.7.2孤儿进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-7-3%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B"><span class="toc-number">3.</span> <span class="toc-text">7.7.3僵尸进程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-8-wait%E5%87%BD%E6%95%B0"><span class="toc-number"></span> <span class="toc-text">7.8 wait函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-8-1%E8%BF%9B%E7%A8%8B%E5%9B%9E%E6%94%B6"><span class="toc-number">1.</span> <span class="toc-text">7.8.1进程回收</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-8-2%E9%80%80%E5%87%BA%E4%BF%A1%E6%81%AF%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="toc-number">2.</span> <span class="toc-text">7.8.2退出信息相关函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-9-waitpid%E5%87%BD%E6%95%B0"><span class="toc-number"></span> <span class="toc-text">7.9 waitpid函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1IPC"><span class="toc-number"></span> <span class="toc-text">8 进程间通信IPC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1IPC%EF%BC%88%E8%BF%9B%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E6%94%B6%E5%8F%91%E6%95%B0%E6%8D%AE%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%89"><span class="toc-number"></span> <span class="toc-text">8.1进程间通信IPC（进程与进程之间收发数据的过程）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">1.</span> <span class="toc-text">Linux进程间通信的方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-%E5%8C%BF%E5%90%8D%E7%AE%A1%E9%81%93%E6%A6%82%E8%BF%B0"><span class="toc-number"></span> <span class="toc-text">8.2 匿名管道概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%92%A5%E7%AE%A1%E9%81%93%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">1.</span> <span class="toc-text">💥管道的特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E7%AE%A1%E9%81%93%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">2.</span> <span class="toc-text">匿名管道的使用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-%E7%88%B6%E5%AD%90%E8%BF%9B%E7%A8%8B%E9%80%9A%E8%BF%87%E5%8C%BF%E5%90%8D%E7%AE%A1%E9%81%93%E9%80%9A%E4%BF%A1"><span class="toc-number"></span> <span class="toc-text">8.3 父子进程通过匿名管道通信</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E7%AE%A1%E9%81%93%E9%80%9A%E4%BF%A1%E6%A1%88%E4%BE%8B"><span class="toc-number">1.</span> <span class="toc-text">匿名管道通信案例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-%E7%AE%A1%E9%81%93%E7%9A%84%E8%AF%BB%E5%86%99%E7%89%B9%E7%82%B9%E5%92%8C%E7%AE%A1%E9%81%93%E8%AE%BE%E7%BD%AE%E4%B8%BA%E9%9D%9E%E9%98%BB%E5%A1%9E"><span class="toc-number"></span> <span class="toc-text">8.4 管道的读写特点和管道设置为非阻塞</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E9%81%93%E7%9A%84%E8%AF%BB%E5%86%99%E7%89%B9%E7%82%B9%EF%BC%9A"><span class="toc-number">1.</span> <span class="toc-text">管道的读写特点：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-5-%E6%9C%89%E5%90%8D%E7%AE%A1%E9%81%93"><span class="toc-number"></span> <span class="toc-text">8.5 有名管道</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E5%90%8D%E7%AE%A1%E9%81%93%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.</span> <span class="toc-text">有名管道的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E5%90%8D%E7%AE%A1%E9%81%93%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">2.</span> <span class="toc-text">有名管道注意事项</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F%E5%8F%91%E9%80%81%E5%AF%B9%E8%AF%9D"><span class="toc-number">2.1.</span> <span class="toc-text">模拟发送对话</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-6-%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84"><span class="toc-number"></span> <span class="toc-text">8.6 内存映射</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.</span> <span class="toc-text">内存映射的注意事项</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E4%BF%A1%E5%8F%B7%E6%A6%82%E8%BF%B0"><span class="toc-number"></span> <span class="toc-text">9.信号概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1%E4%BF%A1%E5%8F%B7%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number"></span> <span class="toc-text">9.1信号的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E7%9A%845%E7%A7%8D%E9%BB%98%E8%AE%A4%E5%A4%84%E7%90%86%E5%8A%A8%E4%BD%9C"><span class="toc-number">1.</span> <span class="toc-text">信号的5种默认处理动作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2kill%E3%80%81raise%E3%80%81abort%E5%87%BD%E6%95%B0"><span class="toc-number"></span> <span class="toc-text">9.2kill、raise、abort函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3alarm-%E5%87%BD%E6%95%B0"><span class="toc-number"></span> <span class="toc-text">9.3alarm 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-4signal%E4%BF%A1%E5%8F%B7%E6%8D%95%E6%8D%89%E5%87%BD%E6%95%B0"><span class="toc-number"></span> <span class="toc-text">9.4signal信号捕捉函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-5%E4%BF%A1%E5%8F%B7%E9%9B%86%E5%8F%8A%E5%85%B6%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="toc-number"></span> <span class="toc-text">9.5信号集及其相关函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%9B%86"><span class="toc-number">1.</span> <span class="toc-text">信号集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sigprocmask%E5%87%BD%E6%95%B0"><span class="toc-number">2.</span> <span class="toc-text">sigprocmask函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sigaction"><span class="toc-number">3.</span> <span class="toc-text">sigaction</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SIGCHLD"><span class="toc-number">4.</span> <span class="toc-text">SIGCHLD</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/27/%E7%BB%8F%E9%AA%8C/" title="经验">经验</a><time datetime="2024-05-27T03:57:23.000Z" title="发表于 2024-05-27 11:57:23">2024-05-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/22/%E5%9F%BA%E4%BA%8E%E6%88%AA%E6%96%AD%E8%87%AA%E9%80%82%E5%BA%94%E6%9D%83%E9%87%8D%E5%85%A8%E5%8F%98%E5%88%86%E7%9A%84%E9%94%A5%E6%9D%9FCT/" title="基于截断自适应权重全变分的锥束CT">基于截断自适应权重全变分的锥束CT</a><time datetime="2024-05-22T15:45:32.000Z" title="发表于 2024-05-22 23:45:32">2024-05-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/22/CT%E6%89%AB%E6%8F%8F%E4%BB%AA/" title="CT扫描仪">CT扫描仪</a><time datetime="2024-05-22T15:38:45.000Z" title="发表于 2024-05-22 23:38:45">2024-05-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/16/Deep%20Learning/" title="Deep Learning">Deep Learning</a><time datetime="2024-05-16T07:43:22.000Z" title="发表于 2024-05-16 15:43:22">2024-05-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/15/MySQL/" title="MySQL">MySQL</a><time datetime="2024-05-15T07:48:58.000Z" title="发表于 2024-05-15 15:48:58">2024-05-15</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Linff214</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><img class="icp-icon" src= "/img/头像.jpg"><span>欢迎来到我的博客😈</span></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(()=>{
  const loadLivere = () => {
    if (typeof LivereTower === 'object') window.LivereTower.init()
    else {
      (function(d, s) {
          var j, e = d.getElementsByTagName(s)[0];
          if (typeof LivereTower === 'function') { return; }
          j = d.createElement(s);
          j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
          j.async = true;
          e.parentNode.insertBefore(j, e);
      })(document, 'script');
    }
  }

  if ('Livere' === 'Livere' || !false) {
    if (false) btf.loadComment(document.getElementById('lv-container'), loadLivere)
    else loadLivere()
  } else {
    window.loadOtherComment = loadLivere
  }
})()</script></div><script async data-pjax src="/js/essay.js"></script><script async data-pjax src="/js/waterfall.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>